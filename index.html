<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flashcard Pro - H·ªçc Th√¥ng Minh</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
<style>
  /* --- BI·∫æN M√ÄU S·∫ÆC & THEME --- */
  :root {
    /* Light Mode - Soft Neumorphism */
    --bg-color-light: #e0e5ec;
    --card-color-light: #e0e5ec;
    --text-main-light: #4a4a4a;
    --text-sub-light: #8993a4;
    --shadow-light-light: #ffffff;
    --shadow-dark-light: #a3b1c6;
    --accent-light: #6c5ce7; 
    
    /* Dark Mode - Deep & Rich */
    --bg-color-dark: #1e272e;
    --card-color-dark: #2f3640;
    --text-main-dark: #dcdde1;
    --text-sub-dark: #7f8fa6;
    --shadow-light-dark: #3f4a5a;
    --shadow-dark-dark: #181d23;
    --accent-dark: #a29bfe;

    /* Default (Light) */
    --bg-color: var(--bg-color-light);
    --card-color: var(--card-color-light);
    --text-main: var(--text-main-light);
    --text-sub: var(--text-sub-light);
    --shadow-light: var(--shadow-light-light);
    --shadow-dark: var(--shadow-dark-light);
    --accent: var(--accent-light);
    
    --success: #00b894;
    --error: #ff7675;
    --warning: #fdcb6e;
    --info: #0984e3;
    --radius: 20px;
    --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
  }
  
  body.dark-mode {
    --bg-color: var(--bg-color-dark);
    --card-color: var(--card-color-dark);
    --text-main: var(--text-main-dark);
    --text-sub: var(--text-sub-dark);
    --shadow-light: var(--shadow-light-dark);
    --shadow-dark: var(--shadow-dark-dark);
    --accent: var(--accent-dark);
  }

  /* Th√™m hi·ªáu ·ª©ng l·∫Øc (Wrong) v√† nh·∫•p nh√°y (Correct) */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translateX(5px); }
  }

  .shake {
    animation: shake 0.4s ease-in-out;
  }
  
  .correct-flash {
    transition: background-color 0.1s;
    animation: flash 0.5s ease-out;
  }
  
  @keyframes flash {
      0% { box-shadow: 0 0 0 0 rgba(0, 184, 148, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(0, 184, 148, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 184, 148, 0); }
  }


  * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
  
  body {
    font-family: 'Nunito', 'Segoe UI', Roboto, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-main);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 80px;
    transition: background-color 0.4s ease, color 0.4s ease;
    overflow-x: hidden;
  }

  /* --- NEUMORPHISM UTILS --- */
  .neu-box {
    background: var(--card-color);
    border-radius: var(--radius);
    box-shadow: 6px 6px 12px var(--shadow-dark), -6px -6px 12px var(--shadow-light);
    border: 1px solid rgba(255,255,255,0.05);
    transition: var(--transition);
  }
  
  .neu-pressed {
    box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light);
  }

  .neu-btn {
    border: none;
    background: var(--card-color);
    color: var(--accent);
    font-weight: 700;
    padding: 14px 24px;
    border-radius: 50px;
    box-shadow: 5px 5px 10px var(--shadow-dark), -5px -5px 10px var(--shadow-light);
    cursor: pointer;
    transition: var(--transition);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
    font-size: 1rem;
    position: relative;
    overflow: hidden;
  }
  
  .neu-btn:active, .neu-btn.active {
    box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
    transform: translateY(2px);
  }
  .neu-btn:disabled { opacity: 0.5; cursor: not-allowed; box-shadow: none; }
  
  /* Th√™m tr·∫°ng th√°i ƒë√∫ng/sai cho button */
  .neu-btn.game-correct { background-color: var(--success); color: white; box-shadow: 0 5px 15px rgba(0, 184, 148, 0.4); }
  .neu-btn.game-wrong { background-color: var(--error); color: white; box-shadow: 0 5px 15px rgba(255, 118, 117, 0.4); }

  .neu-input, .neu-select {
    width: 100%;
    padding: 15px 20px;
    border-radius: 15px;
    border: none;
    background: var(--bg-color);
    box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
    color: var(--text-main);
    font-size: 1rem;
    margin-bottom: 10px;
  }

  /* --- HEADER & LAYOUT --- */
  header {
    text-align: center;
    margin: 40px 0 20px 0;
    width: 90%;
    max-width: 600px;
  }
  h1 { font-size: 2.2rem; color: var(--accent); font-weight: 800; letter-spacing: -1px; margin-bottom: 5px; }
  
  .view-container {
    width: 100%;
    max-width: 800px;
    padding: 0 20px;
    animation: fadeIn 0.4s ease-out;
  }
  
  @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

  /* --- HOME VIEW --- */
  .dashboard-card {
    padding: 25px;
    margin-bottom: 30px;
    text-align: center;
    position: relative;
    overflow: hidden;
  }
  .dashboard-card::before {
    content: ''; position: absolute; top:0; left:0; width: 5px; height: 100%;
    background: var(--accent);
  }
  
  .stats-row {
    display: flex;
    justify-content: space-around;
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid rgba(0,0,0,0.05);
  }
  .stat-item { display: flex; flex-direction: column; }
  .stat-val { font-size: 1.2rem; font-weight: bold; color: var(--text-main); }
  .stat-lbl { font-size: 0.8rem; color: var(--text-sub); }

  .game-mode-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
  }
  .big-play-btn {
    grid-column: 1 / -1;
    background: linear-gradient(135deg, var(--accent), #8e44ad);
    color: white;
    font-size: 1.2rem;
    padding: 20px;
    border-radius: 20px;
    box-shadow: 0 10px 20px rgba(108, 92, 231, 0.3);
  }
  .big-play-btn:hover { transform: translateY(-3px); box-shadow: 0 15px 25px rgba(108, 92, 231, 0.4); }
  
  /* --- CONFIG SLIDERS --- */
  .config-slider-group {
    margin-bottom: 20px;
  }
  .slider-header {
    display: flex; justify-content: space-between; margin-bottom: 5px;
    font-weight: 600; color: var(--text-sub);
  }
  input[type=range] {
    width: 100%;
    -webkit-appearance: none;
    background: transparent;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    height: 20px; width: 20px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    margin-top: -8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  input[type=range]::-webkit-slider-runnable-track {
    width: 100%; height: 4px;
    cursor: pointer;
    background: var(--shadow-dark);
    border-radius: 2px;
  }

  /* --- TOPIC LIST --- */
  .topic-card {
    padding: 20px;
    margin-bottom: 15px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-left: 5px solid transparent;
  }
  .topic-card:hover { transform: translateX(5px); }
  .topic-card.active { border-left-color: var(--success); }
  .topic-info h3 { font-size: 1.1rem; margin-bottom: 5px; }
  .topic-progress-bar {
    height: 6px; width: 100%; background: var(--shadow-dark);
    border-radius: 3px; margin-top: 8px; overflow: hidden;
  }
  .topic-progress-fill { height: 100%; background: var(--success); width: 0%; transition: width 0.5s; }

  /* --- GAME OVERLAY --- */
  #gameOverlay {
    position: fixed; inset: 0;
    background: var(--bg-color);
    z-index: 1000;
    display: none;
    flex-direction: column;
    padding: 20px;
    transition: background-color 0.4s ease;
  }
  
  .game-top-bar {
    display: flex; justify-content: space-between; align-items: center;
    margin-bottom: 20px;
  }
  .progress-container {
    flex-grow: 1; margin: 0 15px;
    height: 8px; background: var(--shadow-dark); border-radius: 4px; overflow: hidden;
  }
  .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }
  
  /* --- FLASHCARD --- */
  .scene {
    width: 100%; max-width: 400px; height: 500px;
    margin: 10px auto;
    perspective: 1000px;
  }
  .card {
    width: 100%; height: 100%;
    position: relative;
    transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    transform-style: preserve-3d;
    cursor: pointer;
  }
  .card.is-flipped { transform: rotateY(180deg); }
  
  .card__face {
    position: absolute;
    width: 100%; height: 100%;
    backface-visibility: hidden;
    border-radius: 30px;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    padding: 30px; text-align: center;
    background: var(--card-color);
    box-shadow: 8px 8px 16px var(--shadow-dark), -8px -8px 16px var(--shadow-light);
  }
  .card__face--back { transform: rotateY(180deg); border: 2px solid var(--accent); }
  
  .word-en { font-size: 2.8rem; font-weight: 800; color: var(--accent); margin-bottom: 10px; line-height: 1.2; }
  .word-ipa { font-size: 1.2rem; color: var(--text-sub); font-family: 'Times New Roman', serif; font-style: italic; margin-bottom: 20px;}
  .word-vn { font-size: 2rem; font-weight: 700; color: var(--text-main); margin-bottom: 15px; }
  
  .game-controls {
    display: flex; justify-content: center; gap: 20px; margin-top: auto;
    width: 100%; max-width: 400px; align-self: center;
  }
  .ctrl-btn {
    width: 60px; height: 60px; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 1.5rem; color: var(--text-sub);
  }
  /* C·∫≠p nh·∫≠t m√†u s·∫Øc cho n√∫t trong Flashcard (cho ch·∫ø ƒë·ªô Smart) */
  .ctrl-btn.correct { color: white; background: var(--success); box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4); }
  .ctrl-btn.wrong { color: white; background: var(--error); box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4); }

  /* --- TAB BAR --- */
  #mainTabBar {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    width: 90%; max-width: 400px;
    height: 70px;
    background: var(--card-color);
    border-radius: 40px;
    box-shadow: 0 10px 25px rgba(0,0,0,0.1);
    display: flex; justify-content: space-around; align-items: center;
    z-index: 100;
    padding: 0 10px;
  }
  .tab-btn {
    flex: 1; display: flex; flex-direction: column; align-items: center;
    color: var(--text-sub); cursor: pointer; transition: 0.3s;
    font-size: 0.75rem; font-weight: 600;
  }
  .tab-btn i { font-size: 1.4rem; margin-bottom: 4px; transition: 0.3s; }
  .tab-btn.active { color: var(--accent); }
  .tab-btn.active i { transform: translateY(-3px); }

  /* --- RESPONSIVE --- */
  @media (max-width: 480px) {
    .scene { height: 400px; }
    .word-en { font-size: 2.2rem; }
    .word-vn { font-size: 1.6rem; }
    .game-mode-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body onload="initApp()">

<header>
  <h1>Flashcard Pro</h1>
  <div id="status-msg" style="font-size:0.9rem; color:var(--text-sub);">H·ªçc t·ª´ v·ª±ng th√¥ng minh</div>
</header>

<div id="appViews" style="width: 100%; flex-grow: 1; display: flex; justify-content: center;">
  
  <div id="homeView" class="view-container">
    <div class="neu-box dashboard-card">
        <div style="font-size:0.9rem; color:var(--text-sub); text-transform: uppercase; letter-spacing: 1px;">Ch·ªß ƒë·ªÅ hi·ªán t·∫°i</div>
        <div id="currentTopicName" style="font-size:1.6rem; font-weight:800; color:var(--text-main); margin:10px 0;">(Ch∆∞a ch·ªçn)</div>
        
        <div class="stats-row">
            <div class="stat-item">
                <span id="statNew" class="stat-val" style="color:var(--info)">0</span>
                <span class="stat-lbl">M·ªõi</span>
            </div>
            <div class="stat-item">
                <span id="statDue" class="stat-val" style="color:var(--warning)">0</span>
                <span class="stat-lbl">C·∫ßn √¥n</span>
            </div>
            <div class="stat-item">
                <span id="statMastered" class="stat-val" style="color:var(--success)">0</span>
                <span class="stat-lbl">ƒê√£ thu·ªôc</span>
            </div>
        </div>
    </div>
    
    <div class="game-mode-grid">
        <button class="neu-btn big-play-btn" onclick="startSmartSession()">
            <i class="fas fa-brain"></i> B·∫Øt ƒë·∫ßu H·ªçc & √în (Duolingo Style)
        </button>
        
        <button class="neu-btn" onclick="startGame('fill')"><i class="fas fa-font"></i> ƒêi·ªÅn t·ª´</button>
        <button class="neu-btn" onclick="startGame('matching')"><i class="fas fa-exchange-alt"></i> Gh√©p ƒë√¥i</button>
        <button class="neu-btn" onclick="startGame('quiz')"><i class="fas fa-check-square"></i> Tr·∫Øc nghi·ªám</button>
        <button class="neu-btn" onclick="startGame('flashcard_all')"><i class="fas fa-layer-group"></i> Xem t·∫•t c·∫£</button>
    </div>
  </div>

  <div id="topicSelectView" class="view-container" style="display:none;">
    <h2 style="margin-bottom: 20px; color:var(--text-main);">Danh s√°ch Ch·ªß ƒë·ªÅ</h2>
    <div id="topicList"></div>
  </div>
  
  <div id="configView" class="view-container" style="display:none;">
    <h2 style="margin-bottom: 20px; color:var(--text-main);">C√†i ƒë·∫∑t</h2>
    <div class="neu-box" style="padding:25px;">
      
      <div style="margin-bottom:25px; display:flex; justify-content:space-between; align-items:center;">
        <span style="font-weight:bold;">Ch·∫ø ƒë·ªô T·ªëi (Dark Mode)</span>
        <button class="neu-btn" id="themeToggleBtn" style="padding:10px 20px;" onclick="toggleTheme()">
            <i class="fas fa-moon"></i>
        </button>
      </div>

      <div style="border-top: 1px solid rgba(0,0,0,0.1); margin: 20px 0;"></div>
      
      <h3 style="color:var(--accent); margin-bottom:15px;">C·∫•u h√¨nh H·ªçc t·∫≠p (Smart Session)</h3>
      
      <div class="config-slider-group">
          <div class="slider-header">
              <span>S·ªë t·ª´ M·ªöI m·ªói l·∫ßn t·∫°o batch</span>
              <span id="dispNewLimit">5</span>
          </div>
          <input type="range" id="cfgNewLimit" min="0" max="20" value="5" oninput="saveConfig()">
      </div>
      
      <div class="config-slider-group">
          <div class="slider-header">
              <span>S·ªë t·ª´ √îN T·∫¨P m·ªói l·∫ßn t·∫°o batch</span>
              <span id="dispReviewLimit">10</span>
          </div>
          <input type="range" id="cfgReviewLimit" min="0" max="50" value="10" oninput="saveConfig()">
      </div>

      <div style="border-top: 1px solid rgba(0,0,0,0.1); margin: 20px 0;"></div>

      <div style="margin-bottom:10px; font-weight:bold;">K·∫øt n·ªëi GitHub</div>
      <input type="text" id="gh-user" class="neu-input" placeholder="Username" value="ngxuanhai123">
      <input type="text" id="gh-repo" class="neu-input" placeholder="Repository" value="tuvung">
      
      <button class="neu-btn" style="width:100%; margin-top:10px; background-color: var(--card-color);" onclick="fetchTopics(true)">
        <i class="fas fa-sync-alt"></i> C·∫≠p nh·∫≠t d·ªØ li·ªáu
      </button>

      <div style="margin-top:20px; font-size:0.9rem; font-weight:bold;">Gi·ªçng ƒë·ªçc:</div>
      <select id="voiceSelect" class="neu-select"></select>
    </div>
  </div>

</div>

<div id="mainTabBar">
  <div class="tab-btn active" data-view="homeView" onclick="switchView('homeView')">
    <i class="fas fa-graduation-cap"></i> H·ªçc t·∫≠p
  </div>
  <div class="tab-btn" data-view="topicSelectView" onclick="switchView('topicSelectView')">
    <i class="fas fa-list-ul"></i> Ch·ªß ƒë·ªÅ
  </div>
  <div class="tab-btn" data-view="configView" onclick="switchView('configView')">
    <i class="fas fa-sliders-h"></i> C√†i ƒë·∫∑t
  </div>
</div>

<div id="gameOverlay">
  <div class="game-top-bar">
    <div class="neu-box" style="padding:10px; border-radius:50%; width:40px; height:40px; display:grid; place-items:center;" onclick="closeGame()">
        <i class="fas fa-times" style="color:var(--error)"></i>
    </div>
    <div class="progress-container">
        <div id="gameProgressBar" class="progress-fill"></div> 
    </div>
    <div class="neu-box" style="padding:10px; border-radius:50%; width:40px; height:40px; display:grid; place-items:center;" onclick="toggleMute()">
        <i id="muteIcon" class="fas fa-volume-up" style="color:var(--accent)"></i>
    </div>
  </div>
  
  <div id="gameContent" style="flex-grow:1; display:flex; flex-direction:column; align-items:center; justify-content:center; width:100%;">
      </div>
</div>

<div id="toastContainer" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); z-index: 2000;"></div>


<script>
  // --- VARIABLES ---
  let allTopics = {};
  let currentTopicKey = localStorage.getItem('last_topic_key');
  let currentSessionWords = []; // Batch words
  let currentIndex = 0;
  let currentMode = '';
  let sessionCounter = 0; // ƒê·ªÉ ƒë·∫øm t·ªïng s·ªë t·ª´ ƒë√£ h·ªçc/√¥n trong 1 l·∫ßn m·ªü Smart Session
  
  // Settings
  let isDarkMode = localStorage.getItem('isDarkMode') === 'true';
  let isMuted = localStorage.getItem('isMuted') === 'true';
  let selectedVoiceURI = localStorage.getItem('selectedVoiceURI') || '';
  
  // Config Limits
  let limitNew = parseInt(localStorage.getItem('cfg_new_limit') || 5);
  let limitReview = parseInt(localStorage.getItem('cfg_review_limit') || 10);

  // DATA STORE
  // masteredWords: { "word_key": true } (User manually marked as mastered)
  let masteredWords = JSON.parse(localStorage.getItem('flashcard_mastered_v2') || '{}');
  
  // srsData: { "word_key": { nextReview: timestamp, interval: days, level: int } }
  let srsData = JSON.parse(localStorage.getItem('flashcard_srs_data') || '{}');
  
  // Bi·∫øn c·ªù ƒë·ªÉ ki·ªÉm so√°t vi·ªác click khi ƒëang x·ª≠ l√Ω ƒë√°p √°n
  let isGameProcessing = false; 

  // --- SOUND EFFECTS (M√¥ ph·ªèng c∆° b·∫£n) ---
  function playSound(type) {
      if (isMuted) return;
      try {
          // D√πng Web Audio API cho √¢m thanh ƒë∆°n gi·∫£n
          const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          
          if (type === 'correct') {
              oscillator.type = 'triangle';
              oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5
              gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
              oscillator.start();
              oscillator.stop(audioCtx.currentTime + 0.3);
          } else if (type === 'wrong') {
              oscillator.type = 'sawtooth';
              oscillator.frequency.setValueAtTime(110, audioCtx.currentTime); // A2
              gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
              oscillator.start();
              oscillator.stop(audioCtx.currentTime + 0.4);
          } else if (type === 'flip') {
              oscillator.type = 'sine';
              oscillator.frequency.setValueAtTime(500, audioCtx.currentTime);
              gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
              oscillator.start();
              oscillator.stop(audioCtx.currentTime + 0.1);
          }
      } catch (e) {
          console.warn("Web Audio API not supported or failed to initialize.", e);
      }
  }

  // --- TOAST/NOTIFICATION ---
  function showToast(message, type = 'info') {
      const toastContainer = document.getElementById('toastContainer');
      const toast = document.createElement('div');
      toast.className = 'neu-box';
      toast.style.padding = '10px 20px';
      toast.style.margin = '10px';
      toast.style.background = `var(--${type})`;
      toast.style.color = 'white';
      toast.style.fontWeight = 'bold';
      toast.style.borderRadius = '10px';
      toast.style.boxShadow = `0 4px 12px rgba(0,0,0,0.2)`;
      toast.style.opacity = '0';
      toast.style.transition = 'opacity 0.3s ease-in-out, transform 0.3s ease-in-out';
      
      let icon = '';
      if (type === 'success') icon = '<i class="fas fa-check-circle"></i> ';
      if (type === 'error') icon = '<i class="fas fa-times-circle"></i> ';

      toast.innerHTML = icon + message;
      toastContainer.appendChild(toast);
      
      setTimeout(() => {
          toast.style.opacity = '1';
          toast.style.transform = 'translateY(0)';
      }, 10);
      
      setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateY(-10px)';
          toast.addEventListener('transitionend', () => toast.remove());
      }, 2500);
  }


  // --- INIT ---
  function initApp() {
    loadTheme();
    updateConfigUI();
    fetchTopics(); // Auto load
    setupVoiceConfig();
    switchView('homeView');
    updateMuteIcon();
  }

  // --- THEME / CONFIG / NAVIGATION (Gi·ªØ nguy√™n) ---
  function loadTheme() {
    document.body.classList.toggle('dark-mode', isDarkMode);
    const btn = document.getElementById('themeToggleBtn');
    btn.innerHTML = isDarkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
  }
  
  function toggleTheme() {
      isDarkMode = !isDarkMode;
      localStorage.setItem('isDarkMode', isDarkMode);
      loadTheme();
  }

  function updateMuteIcon() {
      const icon = document.getElementById('muteIcon');
      icon.className = isMuted ? 'fas fa-volume-mute' : 'fas fa-volume-up';
      icon.style.color = isMuted ? 'var(--text-sub)' : 'var(--accent)';
  }
  
  function toggleMute() {
      isMuted = !isMuted;
      localStorage.setItem('isMuted', isMuted);
      updateMuteIcon();
      window.speechSynthesis.cancel();
  }

  function updateConfigUI() {
      document.getElementById('cfgNewLimit').value = limitNew;
      document.getElementById('dispNewLimit').innerText = limitNew;
      document.getElementById('cfgReviewLimit').value = limitReview;
      document.getElementById('dispReviewLimit').innerText = limitReview;
  }
  
  function saveConfig() {
      limitNew = parseInt(document.getElementById('cfgNewLimit').value);
      limitReview = parseInt(document.getElementById('cfgReviewLimit').value);
      
      document.getElementById('dispNewLimit').innerText = limitNew;
      document.getElementById('dispReviewLimit').innerText = limitReview;
      
      localStorage.setItem('cfg_new_limit', limitNew);
      localStorage.setItem('cfg_review_limit', limitReview);
  }
  
  function switchView(viewId) {
    document.querySelectorAll('.view-container').forEach(el => el.style.display = 'none');
    document.getElementById(viewId).style.display = 'block';
    
    document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.getAttribute('data-view') === viewId) btn.classList.add('active');
    });

    if (viewId === 'topicSelectView') renderTopicList();
    if (viewId === 'homeView') renderDashboard();
  }

  function getWordKey(word) {
      const en = (word.english || '').replace(/\s/g, '').toLowerCase();
      const vn = (word.vietnamese || '').substring(0, 3).replace(/\s/g, '').toLowerCase();
      return `${en}_${vn}`;
  }

  async function fetchTopics(manual = false) {
      const user = document.getElementById('gh-user').value;
      const repo = document.getElementById('gh-repo').value;
      const status = document.getElementById('status-msg');
      
      status.innerText = "ƒêang ƒë·ªìng b·ªô d·ªØ li·ªáu...";
      
      try {
          const apiURL = `https://api.github.com/repos/${user}/${repo}/contents/`;
          const res = await fetch(apiURL);
          if(!res.ok) throw new Error("Kh√¥ng k·∫øt n·ªëi ƒë∆∞·ª£c GitHub");
          
          const files = await res.json();
          const jsonFiles = files.filter(f => f.name.endsWith('.json'));
          
          allTopics = {};
          for (const file of jsonFiles) {
              const raw = await fetch(file.download_url);
              let data = await raw.json();
              let words = Array.isArray(data) ? data : (data.words || []);
              
              if(words.length) {
                  allTopics[file.name] = { 
                      name: (data.name || file.name.replace('.json','')).replace(/_/g,' '), 
                      words 
                  };
              }
          }
          
          status.innerText = "ƒê√£ c·∫≠p nh·∫≠t d·ªØ li·ªáu m·ªõi nh·∫•t.";
          if (!currentTopicKey || !allTopics[currentTopicKey]) {
              currentTopicKey = Object.keys(allTopics)[0]; // Default to first
          }
          if (manual) showToast("C·∫≠p nh·∫≠t th√†nh c√¥ng!", 'success');
          renderDashboard();
          
      } catch (e) {
          status.innerText = "L·ªói: " + e.message;
          console.error(e);
          if (manual) showToast("L·ªói c·∫≠p nh·∫≠t d·ªØ li·ªáu!", 'error');
      }
  }

  function renderDashboard() {
      if (!currentTopicKey || !allTopics[currentTopicKey]) return;
      
      const topic = allTopics[currentTopicKey];
      document.getElementById('currentTopicName').innerText = topic.name;
      
      // Calculate Stats
      let countNew = 0;
      let countDue = 0;
      let countMastered = 0;
      const now = Date.now();
      
      topic.words.forEach(w => {
          const key = getWordKey(w);
          if (masteredWords[key]) {
              countMastered++;
          } else if (srsData[key]) {
              if (srsData[key].nextReview <= now) countDue++;
          } else {
              countNew++;
          }
      });
      
      document.getElementById('statNew').innerText = countNew;
      document.getElementById('statDue').innerText = countDue;
      document.getElementById('statMastered').innerText = countMastered;
  }
  
  function renderTopicList() {
      const listDiv = document.getElementById('topicList');
      listDiv.innerHTML = '';
      
      Object.keys(allTopics).forEach(key => {
          const topic = allTopics[key];
          const div = document.createElement('div');
          div.className = `neu-box topic-card ${key === currentTopicKey ? 'active' : ''}`;
          
          const total = topic.words.length;
          const mastered = topic.words.filter(w => masteredWords[getWordKey(w)]).length;
          const percent = Math.round((mastered / total) * 100) || 0;
          
          div.innerHTML = `
            <div class="topic-info" style="flex-grow:1">
                <h3>${topic.name}</h3>
                <div style="font-size:0.8rem; color:var(--text-sub)">${total} t·ª´ v·ª±ng</div>
                <div class="topic-progress-bar">
                    <div class="topic-progress-fill" style="width:${percent}%"></div>
                </div>
            </div>
            ${key === currentTopicKey ? '<i class="fas fa-check-circle" style="color:var(--success); font-size:1.2rem;"></i>' : ''}
          `;
          div.onclick = () => {
              currentTopicKey = key;
              localStorage.setItem('last_topic_key', key);
              switchView('homeView');
          };
          listDiv.appendChild(div);
      });
  }

  // --- CORE: SMART SESSION (T·ª± ƒë·ªông t·∫°o batch v√† l·∫∑p l·∫°i) ---
  function getNextSessionBatch() {
      if (!currentTopicKey || !allTopics[currentTopicKey]) return [];
      
      const allWords = allTopics[currentTopicKey].words;
      const now = Date.now();
      
      // 1. L·∫•y t·ª´ m·ªõi (Sequential - theo th·ª© t·ª± file)
      const candidatesNew = allWords.filter(w => {
          const key = getWordKey(w);
          return !masteredWords[key] && !srsData[key];
      });
      const batchNew = candidatesNew.slice(0, limitNew);
      
      // 2. L·∫•y t·ª´ c·∫ßn √¥n (SRS Due)
      const candidatesReview = allWords.filter(w => {
          const key = getWordKey(w);
          return !masteredWords[key] && srsData[key] && srsData[key].nextReview <= now;
      });
      // S·∫Øp x·∫øp ∆∞u ti√™n t·ª´ b·ªã "tr·ªÖ" h·∫°n l√¢u nh·∫•t
      candidatesReview.sort((a,b) => srsData[getWordKey(a)].nextReview - srsData[getWordKey(b)].nextReview);
      const batchReview = candidatesReview.slice(0, limitReview);
      
      // 3. G·ªôp l·∫°i v√† tr·ªôn ng·∫´u nhi√™n ƒë·ªÉ xen k·∫Ω
      let session = [...batchNew, ...batchReview];
      session.sort(() => Math.random() - 0.5);
      
      return session;
  }
  
  // H√†m ch√≠nh ƒë·ªÉ b·∫Øt ƒë·∫ßu/ti·∫øp t·ª•c Smart Session
  function startSmartSession() {
      if (!currentTopicKey) return showToast("Vui l√≤ng ch·ªçn ch·ªß ƒë·ªÅ!", 'warning');

      const initialBatch = getNextSessionBatch();
      
      if (initialBatch.length === 0) {
          const allWords = allTopics[currentTopicKey].words;
          const learningCount = allWords.filter(w => srsData[getWordKey(w)] && !masteredWords[getWordKey(w)]).length;
          if (learningCount > 0) {
             showToast("T·∫°m h·∫øt t·ª´ m·ªõi v√† ch∆∞a ƒë·∫øn gi·ªù √¥n l·∫°i t·ª´ c≈©!", 'info');
          } else if (allWords.length > 0) {
             showToast("Ch√∫c m·ª´ng! B·∫°n ƒë√£ h·ªçc h·∫øt v√† thu·ªôc h·∫øt t·ª´ v·ª±ng trong ch·ªß ƒë·ªÅ n√†y.", 'success');
          } else {
             showToast("Ch·ªß ƒë·ªÅ r·ªóng ho·∫∑c ch∆∞a t·∫£i d·ªØ li·ªáu.", 'warning');
          }
          return;
      }
      
      // Kh·ªüi t·∫°o/Ti·∫øp t·ª•c session
      currentSessionWords = initialBatch;
      currentMode = 'smart';
      currentIndex = 0;
      sessionCounter = 0; // Reset counter khi b·∫Øt ƒë·∫ßu
      
      openGameOverlay();
      renderFlashcard(); // Smart Session m·∫∑c ƒë·ªãnh b·∫Øt ƒë·∫ßu b·∫±ng Flashcard
  }
  
  // Chuy·ªÉn sang t·ª´ ti·∫øp theo HO·∫∂C t·∫°o batch m·ªõi n·∫øu h·∫øt t·ª´
  async function advanceCard(isCorrect) {
      if (currentMode === 'smart') {
          // Ch·ªâ c·∫ßn rateWord() ƒë√£ g·ªçi nextCard()
          await rateWord(isCorrect);
      } else {
          // C√°c mode kh√°c (flashcard_all) v·∫´n d√πng nextCard c≈©
          if (currentIndex < currentSessionWords.length - 1) {
              currentIndex++;
              updateProgressBar();
              if (currentMode === 'flashcard_all') renderFlashcard();
              // C√°c mode game kh√¥ng d√πng advanceCard n√†y
          } else {
              showToast("Ho√†n th√†nh phi√™n h·ªçc! üéâ", 'success');
              closeGame();
          }
      }
  }

  function nextCard() {
      // Logic cho Flashcard/Smart Session (sau khi rateWord)
      if (currentIndex < currentSessionWords.length - 1) {
          currentIndex++;
          sessionCounter++;
          updateProgressBar();
          if (currentMode === 'smart' || currentMode === 'flashcard_all') {
              // Th√™m hi·ªáu ·ª©ng chuy·ªÉn ti·∫øp (l√†m m·ªù d·∫ßn)
              const content = document.getElementById('gameContent');
              content.style.opacity = 0;
              setTimeout(() => {
                  renderFlashcard();
                  content.style.opacity = 1;
              }, 300);
          } else if (currentMode === 'fill') {
              renderFill();
          } else if (currentMode === 'quiz') {
              setupQuiz();
          }
      } else if (currentMode === 'smart') {
          // T·ª± ƒë·ªông t·∫°o batch m·ªõi khi h·∫øt batch c≈© (Ch·∫ø ƒë·ªô Duolingo Style)
          const nextBatch = getNextSessionBatch();
          if (nextBatch.length > 0) {
              showToast(`ƒê√£ ho√†n th√†nh ${sessionCounter + 1} t·ª´. Ti·∫øp t·ª•c v·ªõi Batch m·ªõi!`, 'info');
              currentSessionWords = nextBatch;
              currentIndex = 0;
              // Reset game state cho t·ª´ ƒë·∫ßu ti√™n c·ªßa batch m·ªõi
              if (currentMode === 'smart' || currentMode === 'flashcard') {
                 // Ch·ªçn game ng·∫´u nhi√™n cho t·ª´ ƒë·∫ßu ti√™n c·ªßa batch m·ªõi (v√≠ d·ª•: 1/3 l√† Flashcard, 2/3 l√† Game)
                 const nextStep = Math.random();
                 if (nextStep < 0.33) {
                     currentMode = 'smart';
                     renderFlashcard();
                 } else if (nextStep < 0.66) {
                     currentMode = 'quiz';
                     setupQuiz();
                 } else {
                     currentMode = 'fill';
                     renderFill();
                 }
              }
              sessionCounter++;
              updateProgressBar();
          } else {
              showToast(`Ch√∫c m·ª´ng! B·∫°n ƒë√£ ho√†n th√†nh h·∫øt ${sessionCounter + 1} t·ª´ v·ª±ng c·∫ßn h·ªçc v√† √¥n t·∫≠p h√¥m nay!`, 'success');
              closeGame();
          }
      } else {
          // C√°c mode game kh√°c (fill, quiz, matching) v√† flashcard_all k·∫øt th√∫c phi√™n h·ªçc
          showToast("Ho√†n th√†nh phi√™n h·ªçc! üéâ", 'success');
          closeGame();
      }
  }


  function startGame(mode) {
      if (!currentTopicKey) return showToast("Vui l√≤ng ch·ªçn ch·ªß ƒë·ªÅ!", 'warning');
      const allWords = allTopics[currentTopicKey].words;
      
      // Kh·ªüi t·∫°o session d·ª±a tr√™n t·ª´ ƒê√É H·ªåC (ƒë√£ c√≥ trong SRS ho·∫∑c mastered)
      if (mode === 'fill' || mode === 'matching' || mode === 'quiz') {
          const learned = allWords.filter(w => srsData[getWordKey(w)] || masteredWords[getWordKey(w)]);
          if (learned.length < 4 && mode !== 'fill') return showToast("C·∫ßn h·ªçc √≠t nh·∫•t 4 t·ª´ tr∆∞·ªõc khi ch∆°i game n√†y!", 'warning');
          if (learned.length < 1 && mode === 'fill') return showToast("C·∫ßn h·ªçc √≠t nh·∫•t 1 t·ª´ tr∆∞·ªõc khi ch∆°i game n√†y!", 'warning');

          currentSessionWords = learned.sort(() => Math.random() - 0.5); // Shuffle
          currentMode = mode;
      } else if (mode === 'flashcard_all') {
          currentSessionWords = allWords;
          currentMode = 'flashcard_all';
      }
      
      currentIndex = 0;
      sessionCounter = 0;
      openGameOverlay();
      
      if (currentMode === 'flashcard_all') renderFlashcard();
      else if (currentMode === 'fill') renderFill();
      else if (currentMode === 'matching') setupMatching();
      else if (currentMode === 'quiz') setupQuiz();
  }


  function openGameOverlay() {
      document.getElementById('gameOverlay').style.display = 'flex';
      updateProgressBar();
  }
  
  function closeGame() {
      document.getElementById('gameOverlay').style.display = 'none';
      window.speechSynthesis.cancel();
      renderDashboard(); // Update stats
      isGameProcessing = false;
  }

  function updateProgressBar() {
      const bar = document.getElementById('gameProgressBar');
      const pct = ((currentIndex) / currentSessionWords.length) * 100;
      bar.style.width = `${pct}%`;
  }

  // --- FLASHCARD ENGINE (SMART & NORMAL) ---
  let isFlipped = false;
  
  function renderFlashcard() {
      const w = currentSessionWords[currentIndex];
      if(!w) { nextCard(); return; } // B·∫£o v·ªá khi t·ª´ b·ªã null
      isFlipped = false;
      isGameProcessing = false;
      
      const content = document.getElementById('gameContent');
      content.innerHTML = `
        <div class="scene">
            <div class="card" id="flashcard" onclick="flipCard()">
                <div class="card__face card__face--front">
                    <div class="word-en">${w.english}</div>
                    <div class="word-ipa">${w.ipa || ''}</div>
                    <div style="font-size:0.8rem; color:var(--text-sub)">(Ch·∫°m ƒë·ªÉ l·∫≠t)</div>
                </div>
                <div class="card__face card__face--back">
                    <div class="word-vn">${w.vietnamese}</div>
                    <div style="font-style:italic; color:var(--text-sub); margin-top:10px;">"${w.example || ''}"</div>
                </div>
            </div>
        </div>
        
        <div class="game-controls">
             ${currentMode === 'smart' ? `
                <div class="ctrl-btn neu-box wrong" id="rateWrong" onclick="advanceCard(false)"><i class="fas fa-times"></i></div>
                <div class="neu-btn" onclick="speakWord()"><i class="fas fa-volume-up"></i></div>
                <div class="ctrl-btn neu-box correct" id="rateCorrect" onclick="advanceCard(true)"><i class="fas fa-check"></i></div>
             ` : `
                <button class="neu-btn" onclick="prevCard()"><i class="fas fa-arrow-left"></i></button>
                <button class="neu-btn" onclick="speakWord()"><i class="fas fa-volume-up"></i></button>
                <button class="neu-btn" onclick="nextCard()"><i class="fas fa-arrow-right"></i></button>
             `}
        </div>
        <div style="margin-top:20px;">
            <button class="neu-btn" style="font-size:0.8rem; padding:8px 15px; color:var(--warning)" onclick="toggleMasteredCur()">
                <i class="fas fa-bookmark"></i> ƒê√°nh d·∫•u ƒë√£ thu·ªôc
            </button>
        </div>
      `;
      
      setTimeout(speakWord, 300);
  }

  function flipCard() {
      if(isGameProcessing) return;
      const card = document.getElementById('flashcard');
      isFlipped = !isFlipped;
      if(isFlipped) {
          card.classList.add('is-flipped');
          playSound('flip');
      }
      else card.classList.remove('is-flipped');
  }

  // --- SRS ALGORITHM ---
  async function rateWord(isCorrect) {
      if(isGameProcessing) return;
      isGameProcessing = true;
      
      const w = currentSessionWords[currentIndex];
      const key = getWordKey(w);
      
      // L·∫•y data c≈© ho·∫∑c kh·ªüi t·∫°o
      let data = srsData[key] || { interval: 0, level: 0, nextReview: 0 };
      
      if (isCorrect) {
          // Hi·ªáu ·ª©ng ƒê√∫ng
          playSound('correct');
          document.getElementById('rateCorrect').classList.add('correct-flash');
          showToast("ƒê√∫ng! Ti·∫øp t·ª•c n√†o! üí™", 'success');

          // Logic: Level tƒÉng, Interval tƒÉng m·∫°nh
          if (data.level === 0) data.interval = 1; // 1 ng√†y
          else if (data.level === 1) data.interval = 3;
          else data.interval = Math.ceil(data.interval * 2.2);
          
          data.level++;
      } else {
          // Hi·ªáu ·ª©ng Sai
          playSound('wrong');
          document.getElementById('rateWrong').classList.add('shake');
          showToast("Sai r·ªìi. C·ªë g·∫Øng l·∫ßn sau! üòî", 'error');

          // Sai: Reset v·ªÅ level 0, h·ªçc l·∫°i ngay ho·∫∑c ng√†y mai
          data.level = 0;
          data.interval = 0.5; // N·ª≠a ng√†y (√¥n l·∫°i s·ªõm)
          
          // ƒê·∫£m b·∫£o card ƒë√£ l·∫≠t ƒë·ªÉ xem ƒë√°p √°n
          if(!isFlipped) flipCard();
      }
      
      // T√≠nh nextReview (miliseconds)
      // interval * 24h * 60m * 60s * 1000ms
      data.nextReview = Date.now() + (data.interval * 86400000);
      
      // Save
      srsData[key] = data;
      localStorage.setItem('flashcard_srs_data', JSON.stringify(srsData));

      // T·ª± ƒë·ªông chuy·ªÉn ti·∫øp sau 1.5 gi√¢y (d√π ƒë√∫ng hay sai)
      setTimeout(() => {
          isGameProcessing = false;
          // Lo·∫°i b·ªè hi·ªáu ·ª©ng
          document.getElementById('rateCorrect')?.classList.remove('correct-flash');
          document.getElementById('rateWrong')?.classList.remove('shake');
          nextCard();
      }, 1500);
  }
  
  function toggleMasteredCur() {
      if(isGameProcessing) return;
      
      const w = currentSessionWords[currentIndex];
      const key = getWordKey(w);
      if (masteredWords[key]) {
          delete masteredWords[key];
          showToast("ƒê√£ b·ªè ƒë√°nh d·∫•u thu·ªôc.", 'info');
      } else {
          masteredWords[key] = true;
          // X√≥a kh·ªèi SRS ƒë·ªÉ kh√¥ng nh·∫Øc l·∫°i n·ªØa
          if(srsData[key]) delete srsData[key];
          localStorage.setItem('flashcard_srs_data', JSON.stringify(srsData));
          showToast("ƒê√£ ƒë√°nh d·∫•u thu·ªôc! S·∫Ω kh√¥ng xu·∫•t hi·ªán l·∫°i.", 'success');
          // Chuy·ªÉn t·ª´ sau khi ƒë√°nh d·∫•u thu·ªôc
          nextCard();
      }
      localStorage.setItem('flashcard_mastered_v2', JSON.stringify(masteredWords));
  }

  // --- FILL GAME ---
  function renderFill() {
    isGameProcessing = false;
    const w = currentSessionWords[currentIndex];
    if(!w) { nextCard(); return; }
    
    const sentence = w.example || `The word is ${w.english}`;
    const hidden = sentence.replace(new RegExp(w.english, 'gi'), '_____');
    
    document.getElementById('gameContent').innerHTML = `
        <div style="font-size:1.2rem; margin-bottom:20px; text-align:center;">
            <i class="fas fa-quote-left" style="color:var(--accent)"></i> 
            ${hidden} 
            <i class="fas fa-quote-right" style="color:var(--accent)"></i>
        </div>
        <div style="margin-bottom:10px; color:var(--text-sub)">Nghƒ©a: ${w.vietnamese}</div>
        <input type="text" id="fillInput" class="neu-input" placeholder="Nh·∫≠p t·ª´ c√≤n thi·∫øu..." autocomplete="off">
        <button class="neu-btn" id="fillCheckBtn" style="width:100%; margin-top:20px; background-color: var(--card-color);" onclick="checkFill('${w.english}')">Ki·ªÉm tra</button>
    `;
    setTimeout(speakWord, 300);
  }
  
  function checkFill(ans) {
      if(isGameProcessing) return;
      isGameProcessing = true;
      
      const val = document.getElementById('fillInput').value;
      const checkBtn = document.getElementById('fillCheckBtn');
      const w = currentSessionWords[currentIndex];

      if (val.toLowerCase().trim() === ans.toLowerCase().trim()) {
          // ƒê√∫ng
          checkBtn.classList.add('game-correct', 'correct-flash');
          playSound('correct');
          showToast("Ch√≠nh x√°c! üéâ", 'success');
          
          // C·∫≠p nh·∫≠t SRS
          rateWordGame(w, true);
          
          setTimeout(() => {
              isGameProcessing = false;
              nextCard();
          }, 1500);

      } else {
          // Sai - T·ª± ƒë·ªông s·ª≠a v√† ch·ªù x√°c nh·∫≠n
          checkBtn.classList.add('game-wrong', 'shake');
          playSound('wrong');
          document.getElementById('fillInput').value = ans;
          showToast(`Sai r·ªìi. ƒê√°p √°n l√†: ${ans}`, 'error');
          
          // C·∫≠p nh·∫≠t SRS l√† sai
          rateWordGame(w, false);

          // Chuy·ªÉn n√∫t Ki·ªÉm tra th√†nh n√∫t Ti·∫øp t·ª•c
          checkBtn.innerHTML = `Ti·∫øp t·ª•c <i class="fas fa-arrow-right"></i>`;
          checkBtn.onclick = () => {
              checkBtn.classList.remove('game-wrong', 'shake');
              isGameProcessing = false;
              nextCard();
          };
      }
  }
  
  // H√†m c·∫≠p nh·∫≠t SRS cho c√°c Game Mode
  function rateWordGame(word, isCorrect) {
      const key = getWordKey(word);
      let data = srsData[key] || { interval: 0, level: 0, nextReview: 0 };

      if (isCorrect) {
          if (data.level === 0) data.interval = 1; 
          else if (data.level === 1) data.interval = 3;
          else data.interval = Math.ceil(data.interval * 2.2);
          data.level++;
      } else {
          data.level = 0;
          data.interval = 0.5;
      }
      data.nextReview = Date.now() + (data.interval * 86400000);
      
      srsData[key] = data;
      localStorage.setItem('flashcard_srs_data', JSON.stringify(srsData));
  }


  // --- MATCHING GAME ---
  function setupMatching() {
      isGameProcessing = false;
      // Ch·ªâ l·∫•y t·ª´ ƒë√£ h·ªçc
      const allLearned = allTopics[currentTopicKey].words.filter(w => srsData[getWordKey(w)] || masteredWords[getWordKey(w)]);
      
      // Ch·ªçn ng·∫´u nhi√™n 4 t·ª´ t·ª´ danh s√°ch ƒë√£ h·ªçc
      const selectedWords = allLearned.sort(() => Math.random() - 0.5).slice(0, 4);
      if (selectedWords.length < 2) { 
          // N·∫øu kh√¥ng ƒë·ªß 4 t·ª´ (c·∫ßn √≠t nh·∫•t 2 ƒë·ªÉ ch∆°i matching)
          showToast("Kh√¥ng ƒë·ªß t·ª´ ƒë√£ h·ªçc ƒë·ªÉ ch∆°i Gh√©p ƒë√¥i!", 'warning');
          closeGame(); 
          return; 
      } 
      
      // C·∫≠p nh·∫≠t currentSessionWords ch·ªâ v·ªõi c√°c t·ª´ n√†y
      currentSessionWords = selectedWords; 
      currentIndex = 0; // Lu√¥n b·∫Øt ƒë·∫ßu t·ª´ 0 cho game
      updateProgressBar();

      let items = [];
      selectedWords.forEach((w, i) => {
          // L∆∞u key ƒë·ªÉ c·∫≠p nh·∫≠t SRS sau
          w.tempMatchKey = i; 
          items.push({ txt: w.english, id: i, type: 'en', word: w });
          items.push({ txt: w.vietnamese, id: i, type: 'vn', word: w });
      });
      items.sort(() => Math.random() - 0.5);
      
      let html = `<div id="matchingGrid" style="display:grid; grid-template-columns:1fr 1fr; gap:15px; width:100%;">`;
      items.forEach((item, idx) => {
          html += `<div class="neu-box matching-item" id="match-${idx}" data-match-id="${item.id}" data-word-key="${getWordKey(item.word)}" data-index="${idx}" style="padding:20px; text-align:center; cursor:pointer;" onclick="handleMatch(this)">${item.txt}</div>`;
      });
      html += `</div>`;
      
      document.getElementById('gameContent').innerHTML = html;
      window.matchState = { selected: null, solved: 0, total: selectedWords.length, allItems: items };
  }
  
  window.handleMatch = function(el) {
      if(isGameProcessing) return;

      const state = window.matchState;
      const id = parseInt(el.getAttribute('data-match-id'));
      const idx = parseInt(el.getAttribute('data-index'));
      const key = el.getAttribute('data-word-key');
      
      if(el.classList.contains('matched') || el.classList.contains('neu-pressed')) return;
      
      el.classList.add('neu-pressed');
      playSound('flip');
      
      if (state.selected === null) {
          state.selected = { el, id, key };
      } else {
          isGameProcessing = true;
          if (state.selected.id === id) {
              // Match - ƒê√∫ng
              playSound('correct');
              showToast("Gh√©p ƒë√¥i th√†nh c√¥ng!", 'success');
              
              // C·∫≠p nh·∫≠t SRS cho t·ª´ n√†y l√† ƒê√∫ng
              const matchedWord = state.allItems.find(item => item.id === id).word;
              rateWordGame(matchedWord, true);

              el.style.background = 'var(--success)';
              state.selected.el.style.background = 'var(--success)';
              el.classList.add('matched');
              state.selected.el.classList.add('matched');

              setTimeout(() => {
                  el.style.opacity = 0;
                  state.selected.el.style.opacity = 0;
                  state.solved++;
                  
                  if(state.solved === state.total) {
                      // H·∫øt game matching, chuy·ªÉn sang game m·ªõi (ho·∫∑c flashcard)
                      showToast("Ho√†n th√†nh! Chu·∫©n b·ªã cho t·ª´ m·ªõi...", 'info');
                      isGameProcessing = false;
                      startSmartSession(); // Quay l·∫°i Smart Session
                  } else {
                      isGameProcessing = false;
                  }
              }, 800);
          } else {
              // Mismatch - Sai
              playSound('wrong');
              showToast("Sai r·ªìi, th·ª≠ l·∫°i nh√©!", 'error');
              
              // C·∫≠p nh·∫≠t SRS cho c·∫£ 2 t·ª´ l√† Sai (v√¨ ƒë·ªÅu ƒë√£ ƒë∆∞·ª£c ch·ªçn)
              const word1 = state.allItems.find(item => item.id === state.selected.id).word;
              const word2 = state.allItems.find(item => item.id === id).word;
              rateWordGame(word1, false);
              rateWordGame(word2, false);

              el.style.background = 'var(--error)';
              state.selected.el.style.background = 'var(--error)';
              
              // T·ª± ƒë·ªông b·ªè ch·ªçn sau 1s
              setTimeout(() => {
                  el.style.background = 'var(--card-color)';
                  state.selected.el.style.background = 'var(--card-color)';
                  el.classList.remove('neu-pressed');
                  state.selected.el.classList.remove('neu-pressed');
                  isGameProcessing = false;
              }, 1000);
          }
          state.selected = null;
      }
  }


  // --- QUIZ GAME ---
  function setupQuiz() {
      isGameProcessing = false;
      const w = currentSessionWords[currentIndex];
      if(!w) { nextCard(); return; }

      // T·∫°o distractors (ch·ªâ l·∫•y t·ª´ ƒë√£ h·ªçc)
      const learnedWords = allTopics[currentTopicKey].words.filter(w => srsData[getWordKey(w)] || masteredWords[getWordKey(w)]);
      
      const distractors = learnedWords
          .filter(wi => getWordKey(wi) !== getWordKey(w)) // Lo·∫°i b·ªè t·ª´ hi·ªán t·∫°i
          .sort(() => Math.random() - 0.5)
          .slice(0, 3);
          
      const options = [{w, correct:true}, ...distractors.map(d=>({w:d, correct:false}))].sort(()=>Math.random()-0.5);
      
      let html = `
          <div style="font-size:1.5rem; color:var(--accent); font-weight:bold; margin-bottom:20px;">${w.english}</div>
          <div id="quizOptions" style="display:grid; gap:15px; width:100%;">
      `;
      options.forEach((opt, index) => {
          html += `<button class="neu-btn quiz-opt" data-correct="${opt.correct}" data-word-key="${getWordKey(opt.w)}" id="quiz-opt-${index}" style="justify-content:center; background-color: var(--card-color);" onclick="checkQuiz(this, ${opt.correct})">${opt.w.vietnamese}</button>`;
      });
      html += `</div>`;
      document.getElementById('gameContent').innerHTML = html;
      setTimeout(speakWord, 300);
  }
  
  window.checkQuiz = function(el, isCorrect) {
      if(isGameProcessing) return;
      isGameProcessing = true;
      
      const correctEl = document.querySelector('[data-correct="true"]');
      const w = currentSessionWords[currentIndex];

      if(isCorrect) {
          // ƒê√∫ng - T·ª± ƒë·ªông chuy·ªÉn
          el.classList.add('game-correct', 'correct-flash');
          playSound('correct');
          showToast("Tuy·ªát v·ªùi! Ch√≠nh x√°c! üéâ", 'success');
          
          // C·∫≠p nh·∫≠t SRS cho t·ª´ ƒë√∫ng
          rateWordGame(w, true);

          setTimeout(() => {
              isGameProcessing = false;
              nextCard();
          }, 1500);
          
      } else {
          // Sai - T·ª± ƒë·ªông ch·ªçn ƒë√°p √°n ƒë√∫ng v√† ch·ªù x√°c nh·∫≠n
          el.classList.add('game-wrong', 'shake');
          correctEl.classList.add('game-correct'); // Highlight ƒë√°p √°n ƒë√∫ng
          playSound('wrong');
          showToast(`Sai r·ªìi. ƒê√°p √°n l√†: ${correctEl.innerText}`, 'error');
          
          // C·∫≠p nh·∫≠t SRS cho t·ª´ sai
          rateWordGame(w, false);

          // V√¥ hi·ªáu h√≥a t·∫•t c·∫£ n√∫t v√† thay th·∫ø n√∫t ƒë√£ ch·ªçn b·∫±ng Ti·∫øp t·ª•c
          document.querySelectorAll('.quiz-opt').forEach(btn => btn.disabled = true);
          el.innerText = 'Ti·∫øp t·ª•c';
          el.onclick = () => {
              isGameProcessing = false;
              nextCard();
          };
      }
  }

  // --- TTS (Gi·ªØ nguy√™n) ---
  function setupVoiceConfig() {
      const select = document.getElementById('voiceSelect');
      const voices = window.speechSynthesis.getVoices().filter(v => v.lang.startsWith('en'));
      
      if(voices.length === 0) {
          window.speechSynthesis.onvoiceschanged = setupVoiceConfig;
          return;
      }
      
      select.innerHTML = '';
      voices.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.voiceURI;
          opt.innerText = v.name;
          if (v.voiceURI === selectedVoiceURI) opt.selected = true;
          select.appendChild(opt);
      });
      
      select.onchange = () => {
          selectedVoiceURI = select.value;
          localStorage.setItem('selectedVoiceURI', selectedVoiceURI);
      }
  }

  function speakWord() {
      if (isMuted) return;
      const w = currentSessionWords[currentIndex];
      if(!w) return;
      
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(w.english);
      const voices = window.speechSynthesis.getVoices();
      const v = voices.find(voice => voice.voiceURI === selectedVoiceURI);
      if(v) u.voice = v;
      
      window.speechSynthesis.speak(u);
  }

</script>
</body>
</html>
