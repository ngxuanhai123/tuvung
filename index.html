<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flashcard Pro - Cam</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
<style>
  /* --- 1. THEME & VARIABLES (ORANGE DUOLINGO STYLE) --- */
  :root {
    --primary: #ff9f43;      /* Cam s√°ng */
    --primary-dark: #ee5253; /* Cam ƒë·ªè (khi nh·∫•n) */
    --accent: #54a0ff;       /* Xanh d∆∞∆°ng nh·∫°t */
    
    --success: #1dd1a1;      /* Xanh l√° */
    --success-dark: #10ac84;
    --error: #ff6b6b;        /* ƒê·ªè h·ªìng */
    --error-dark: #ee5253;
    
    --bg-color: #ffffff;
    --surface: #f7f1e3;      /* M√†u kem nh·∫°t l√†m n·ªÅn ph·ª• */
    --text-main: #2d3436;
    --text-sub: #636e72;
    --border-radius: 16px;
    
    --shadow-btn: 0px 4px 0px rgba(0,0,0,0.15);
    --shadow-btn-active: 0px 2px 0px rgba(0,0,0,0.15);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; user-select: none; }
  
  body {
    font-family: 'Nunito', 'Segoe UI', Roboto, sans-serif;
    background-color: var(--bg-color);
    color: var(--text-main);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    overflow-x: hidden;
  }

  /* --- UI COMPONENTS --- */
  
  /* N√∫t b·∫•m 3D */
  .btn-3d {
    border: none;
    background-color: var(--surface);
    color: var(--text-main);
    padding: 15px 20px;
    border-radius: var(--border-radius);
    font-weight: 800;
    font-size: 1rem;
    cursor: pointer;
    box-shadow: 0px 4px 0px #d1d8e0; /* Shadow c·ª©ng */
    transition: all 0.1s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: inline-flex; align-items: center; justify-content: center; gap: 10px;
    border: 2px solid #d1d8e0;
  }
  .btn-3d:active {
    transform: translateY(4px);
    box-shadow: none;
  }
  
  .btn-primary {
    background-color: var(--primary);
    color: white;
    border-color: #e67e22;
    box-shadow: 0px 4px 0px #e67e22;
  }
  .btn-primary:active { box-shadow: none; transform: translateY(4px); }

  .btn-success {
    background-color: var(--success);
    color: white;
    border-color: var(--success-dark);
    box-shadow: 0px 4px 0px var(--success-dark);
  }
  
  .btn-error {
    background-color: var(--error);
    color: white;
    border-color: var(--error-dark);
    box-shadow: 0px 4px 0px var(--error-dark);
  }

  .btn-icon { width: 50px; height: 50px; padding: 0; border-radius: 50%; }

  /* Input */
  .input-ui {
    width: 100%;
    padding: 15px;
    border: 2px solid #d1d8e0;
    border-radius: var(--border-radius);
    background: #fdfdfd;
    font-size: 1.1rem;
    color: var(--text-main);
    transition: 0.3s;
  }
  .input-ui:focus { border-color: var(--accent); }

  /* Card Container */
  .card-box {
    background: white;
    border: 2px solid #eee;
    border-radius: var(--border-radius);
    padding: 20px;
    margin-bottom: 20px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.05);
  }

  /* --- LAYOUT --- */
  header {
    padding: 20px;
    text-align: center;
    border-bottom: 2px solid #f1f2f6;
  }
  h1 { color: var(--primary); font-weight: 900; letter-spacing: -1px; }

  .view-container {
    width: 100%; max-width: 600px;
    margin: 0 auto;
    padding: 20px;
    flex-grow: 1;
    display: none; /* JS will toggle */
    animation: slideIn 0.3s ease-out;
  }
  .view-active { display: block; }

  @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

  /* --- FLASHCARD SCENE --- */
  .scene {
    width: 100%; height: 400px;
    perspective: 1000px;
    margin: 20px 0;
  }
  .card {
    width: 100%; height: 100%;
    position: relative;
    transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
    transform-style: preserve-3d;
    cursor: pointer;
  }
  .card.is-flipped { transform: rotateY(180deg); }
  
  .card__face {
    position: absolute;
    width: 100%; height: 100%;
    backface-visibility: hidden;
    border-radius: 25px;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    padding: 20px; text-align: center;
    background: white;
    border: 2px solid #e5e5e5;
    box-shadow: 0 8px 0 #e5e5e5;
  }
  .card__face--back { transform: rotateY(180deg); border-color: var(--accent); box-shadow: 0 8px 0 #74b9ff; }
  
  .word-en { font-size: 2.5rem; font-weight: 800; color: var(--primary); margin-bottom: 10px; }
  .word-ipa { font-size: 1.2rem; color: var(--text-sub); font-style: italic; font-family: serif; }
  .word-vn { font-size: 2rem; font-weight: 700; color: var(--text-main); }

  /* --- GAME OVERLAY & FEEDBACK --- */
  #gameOverlay {
    position: fixed; inset: 0;
    background: var(--bg-color);
    z-index: 1000;
    display: none;
    flex-direction: column;
  }
  
  .game-header {
    padding: 15px 20px;
    display: flex; align-items: center; gap: 15px;
  }
  
  .progress-bar {
    flex-grow: 1; height: 16px;
    background: #e5e5e5;
    border-radius: 10px;
    overflow: hidden;
    position: relative;
  }
  .progress-fill {
    height: 100%; background: var(--primary);
    width: 0%; transition: width 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    border-radius: 10px;
  }
  .progress-highlight {
    position: absolute; top: 0; right: 0; width: 100%; height: 4px;
    background: rgba(255,255,255,0.3); border-radius: 10px;
  }

  /* Bottom Sheet Feedback (Duolingo Style) */
  #feedbackSheet {
    position: fixed; bottom: 0; left: 0; width: 100%;
    padding: 20px;
    background: white;
    border-top: 2px solid #eee;
    transform: translateY(110%);
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    z-index: 1100;
    display: flex; flex-direction: column; gap: 10px;
  }
  #feedbackSheet.show { transform: translateY(0); }
  
  #feedbackSheet.correct { background: #dff9fb; border-color: var(--success); }
  #feedbackSheet.correct .fb-title { color: var(--success); }
  
  #feedbackSheet.wrong { background: #ffeded; border-color: var(--error); }
  #feedbackSheet.wrong .fb-title { color: var(--error); }
  
  .fb-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 5px; }
  .fb-msg { font-size: 1rem; color: var(--text-main); margin-bottom: 15px; }

  /* Effects */
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-10px); }
    75% { transform: translateX(10px); }
  }
  .shake-anim { animation: shake 0.4s ease-in-out; }
  
  /* Confetti (Simple CSS) */
  .confetti { position: fixed; width: 10px; height: 10px; background-color: #f00; animation: fall linear forwards; z-index: 9999; }
  @keyframes fall { to { transform: translateY(100vh) rotate(720deg); } }

  /* --- LISTS --- */
  .topic-item {
    display: flex; justify-content: space-between; align-items: center;
    padding: 15px; background: white; border: 2px solid #eee;
    border-radius: var(--border-radius); margin-bottom: 10px; cursor: pointer;
    transition: 0.2s;
  }
  .topic-item:hover { border-color: var(--primary); transform: translateX(5px); }
  .topic-item.active { border-color: var(--primary); background: #fff5eb; }

  /* Footer Tab */
  .tab-bar {
    position: fixed; bottom: 0; width: 100%;
    background: white; border-top: 2px solid #f1f2f6;
    display: flex; justify-content: space-around; padding: 10px 0 20px;
    z-index: 500;
  }
  .tab-item {
    display: flex; flex-direction: column; align-items: center;
    color: #b2bec3; font-weight: 700; font-size: 0.8rem; cursor: pointer;
  }
  .tab-item i { font-size: 1.5rem; margin-bottom: 5px; }
  .tab-item.active { color: var(--primary); }

</style>
</head>
<body onload="initApp()">

<script>
    // Simple Synth to avoid loading MP3s
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSound(type) {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        const now = audioCtx.currentTime;
        if(type === 'correct') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'wrong') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(100, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'fanfare') {
             // Triple beep
             [0, 0.15, 0.3].forEach((t, i) => {
                 const o = audioCtx.createOscillator();
                 const g = audioCtx.createGain();
                 o.connect(g); g.connect(audioCtx.destination);
                 o.frequency.value = 400 + (i*200);
                 g.gain.value = 0.2; g.gain.exponentialRampToValueAtTime(0.01, now + t + 0.3);
                 o.start(now + t); o.stop(now + t + 0.3);
             });
        }
    }
</script>

<header>
  <h1>Flashcard Pro</h1>
</header>

<div id="homeView" class="view-container view-active">
    <div class="card-box" style="text-align: center;">
        <h3 style="color:var(--text-sub); font-size:0.9rem; text-transform:uppercase;">Ch·ªß ƒë·ªÅ hi·ªán t·∫°i</h3>
        <h2 id="currentTopicName" style="font-size:1.8rem; color:var(--primary); margin:10px 0;">(Ch∆∞a ch·ªçn)</h2>
        
        <div style="display:flex; justify-content:space-around; margin-top:20px; padding-top:15px; border-top:2px solid #f1f2f6;">
            <div>
                <div id="statNew" style="font-size:1.5rem; font-weight:800; color:var(--accent)">0</div>
                <div style="font-size:0.8rem; color:var(--text-sub)">M·ªõi</div>
            </div>
            <div>
                <div id="statReview" style="font-size:1.5rem; font-weight:800; color:var(--error)">0</div>
                <div style="font-size:0.8rem; color:var(--text-sub)">C·∫ßn √¥n</div>
            </div>
            <div>
                <div id="statMaster" style="font-size:1.5rem; font-weight:800; color:var(--success)">0</div>
                <div style="font-size:0.8rem; color:var(--text-sub)">ƒê√£ thu·ªôc</div>
            </div>
        </div>
    </div>

    <button class="btn-3d btn-primary" style="width:100%; margin-bottom:15px; font-size:1.2rem; padding:20px;" onclick="startGame('smart')">
        <i class="fas fa-play"></i> B·∫ÆT ƒê·∫¶U H·ªåC NGAY
    </button>
    
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
        <button class="btn-3d" onclick="startGame('fill')"><i class="fas fa-keyboard" style="color:var(--accent)"></i> ƒêi·ªÅn t·ª´</button>
        <button class="btn-3d" onclick="startGame('quiz')"><i class="fas fa-check-square" style="color:var(--primary)"></i> Tr·∫Øc nghi·ªám</button>
        <button class="btn-3d" onclick="startGame('matching')"><i class="fas fa-columns" style="color:var(--success)"></i> Gh√©p ƒë√¥i</button>
        <button class="btn-3d" onclick="startGame('flashcard')"><i class="fas fa-layer-group" style="color:var(--text-sub)"></i> Xem t·∫•t c·∫£</button>
    </div>
</div>

<div id="topicView" class="view-container">
    <h2>Danh s√°ch ch·ªß ƒë·ªÅ</h2>
    <div id="topicList" style="margin-top:20px;"></div>
</div>

<div id="settingsView" class="view-container">
    <h2>C√†i ƒë·∫∑t</h2>
    <div class="card-box">
        <div style="margin-bottom:15px;">
            <label>GitHub User</label>
            <input type="text" id="gh-user" class="input-ui" value="ngxuanhai123">
        </div>
        <div style="margin-bottom:15px;">
            <label>Repo Name</label>
            <input type="text" id="gh-repo" class="input-ui" value="tuvung">
        </div>
        <button class="btn-3d btn-primary" style="width:100%" onclick="fetchTopics(true)">
            <i class="fas fa-sync"></i> C·∫≠p nh·∫≠t d·ªØ li·ªáu
        </button>
    </div>
    
    <div class="card-box">
         <label>Gi·ªçng ƒë·ªçc (TTS)</label>
         <select id="voiceSelect" class="input-ui" style="margin-top:10px;"></select>
    </div>
</div>

<div id="gameOverlay">
    <div class="game-header">
        <button class="btn-3d btn-icon" onclick="quitGame()" style="width:40px; height:40px;"><i class="fas fa-times"></i></button>
        <div class="progress-bar"><div id="gameProgress" class="progress-fill"><div class="progress-highlight"></div></div></div>
        <div style="font-weight:800; color:var(--primary);" id="streakCounter">üî• 0</div>
    </div>
    
    <div id="gameBody" style="flex-grow:1; display:flex; flex-direction:column; justify-content:center; align-items:center; padding:20px; overflow-y:auto;">
        </div>
    
    <div style="height: 180px;"></div>
    
    <div id="feedbackSheet">
        <div class="fb-content">
            <div class="fb-title" id="fbTitle">Ch√≠nh x√°c!</div>
            <div class="fb-msg" id="fbMessage"></div>
            <button id="fbBtn" class="btn-3d" style="width:100%;" onclick="handleFeedbackContinue()">TI·∫æP T·ª§C</button>
        </div>
    </div>
</div>

<div class="tab-bar">
    <div class="tab-item active" onclick="nav('homeView', this)"><i class="fas fa-home"></i>H·ªçc t·∫≠p</div>
    <div class="tab-item" onclick="nav('topicView', this)"><i class="fas fa-list"></i>Ch·ªß ƒë·ªÅ</div>
    <div class="tab-item" onclick="nav('settingsView', this)"><i class="fas fa-cog"></i>C√†i ƒë·∫∑t</div>
</div>

<script>
/**
 * --- APP STATE & DATA ---
 */
let allTopics = {};
let currentTopicKey = localStorage.getItem('last_topic_key');
let srsData = JSON.parse(localStorage.getItem('srs_db_v3') || '{}');
// SRS Structure: { "wordID": { level: 0, nextReview: timestamp, interval: days } }

let gameQueue = []; // Queue of objects: { word: {...}, type: 'new'|'review'|'mistake' }
let currentItem = null;
let currentMode = '';
let streak = 0;
let sessionCorrect = 0;
let totalSessionItems = 0; // For progress bar base
let selectedVoiceURI = localStorage.getItem('voice_uri') || '';

/**
 * --- INIT ---
 */
function initApp() {
    setupVoices();
    fetchTopics();
    updateDashboard();
}

function nav(viewId, btn) {
    document.querySelectorAll('.view-container').forEach(el => el.classList.remove('view-active'));
    document.getElementById(viewId).classList.add('view-active');
    
    document.querySelectorAll('.tab-item').forEach(el => el.classList.remove('active'));
    if(btn) btn.classList.add('active');
    
    if(viewId === 'topicView') renderTopics();
    if(viewId === 'homeView') updateDashboard();
}

/**
 * --- DATA SYNC ---
 */
function getWordID(w) { return (w.english + '_' + w.vietnamese).replace(/\s/g,'').toLowerCase(); }

async function fetchTopics(manual=false) {
    const u = document.getElementById('gh-user').value;
    const r = document.getElementById('gh-repo').value;
    
    try {
        const listUrl = `https://api.github.com/repos/${u}/${r}/contents/`;
        const res = await fetch(listUrl);
        if(!res.ok) throw new Error("Repo not found");
        const files = await res.json();
        const jsonFiles = files.filter(f => f.name.endsWith('.json'));
        
        allTopics = {};
        for(const f of jsonFiles) {
            const raw = await fetch(f.download_url);
            const data = await raw.json();
            let words = Array.isArray(data) ? data : (data.words || []);
            allTopics[f.name] = { name: (data.name || f.name), words: words };
        }
        
        if(!currentTopicKey && Object.keys(allTopics).length > 0) currentTopicKey = Object.keys(allTopics)[0];
        
        if(manual) alert("C·∫≠p nh·∫≠t th√†nh c√¥ng!");
        updateDashboard();
    } catch(e) {
        console.error(e);
        if(manual) alert("L·ªói k·∫øt n·ªëi GitHub!");
    }
}

function updateDashboard() {
    if(!currentTopicKey || !allTopics[currentTopicKey]) return;
    document.getElementById('currentTopicName').innerText = allTopics[currentTopicKey].name;
    
    const words = allTopics[currentTopicKey].words;
    const now = Date.now();
    let n=0, r=0, m=0;
    
    words.forEach(w => {
        const id = getWordID(w);
        const s = srsData[id];
        if(!s) n++;
        else if(s.level >= 5) m++; // Level 5 considered Mastered
        else if(s.nextReview <= now) r++;
        else m++; // In waiting state, technically learned
    });
    
    document.getElementById('statNew').innerText = n;
    document.getElementById('statReview').innerText = r;
    document.getElementById('statMaster').innerText = m;
}

function renderTopics() {
    const list = document.getElementById('topicList');
    list.innerHTML = '';
    Object.keys(allTopics).forEach(k => {
        const t = allTopics[k];
        const div = document.createElement('div');
        div.className = `topic-item ${k===currentTopicKey ? 'active' : ''}`;
        div.innerHTML = `<div><strong>${t.name}</strong><br><small>${t.words.length} t·ª´</small></div>`;
        if(k === currentTopicKey) div.innerHTML += `<i class="fas fa-check-circle" style="color:var(--success)"></i>`;
        div.onclick = () => {
            currentTopicKey = k;
            localStorage.setItem('last_topic_key', k);
            nav('homeView', document.querySelector('.tab-item:first-child'));
        };
        list.appendChild(div);
    });
}

/**
 * --- GAME LOGIC ENGINE (THE CORE) ---
 */

function startGame(mode) {
    if(!currentTopicKey) return alert("Ch∆∞a c√≥ d·ªØ li·ªáu!");
    currentMode = mode;
    gameQueue = [];
    streak = 0;
    sessionCorrect = 0;
    
    const words = allTopics[currentTopicKey].words;
    
    if(mode === 'smart') {
        // BUILD SMART QUEUE
        const now = Date.now();
        // 1. Get Review Words (Due)
        const due = words.filter(w => {
            const s = srsData[getWordID(w)];
            return s && s.nextReview <= now && s.level < 5;
        }).map(w => ({ word: w, type: 'review' }));
        
        // 2. Get New Words (Limit 5 per session initial)
        const newW = words.filter(w => !srsData[getWordID(w)]).slice(0, 5)
                          .map(w => ({ word: w, type: 'new' }));
        
        // 3. Mix them (Interleave)
        gameQueue = [...due, ...newW];
        if(gameQueue.length === 0) {
            // If empty, fetch random learned words for practice
            const learned = words.filter(w => srsData[getWordID(w)]);
            if(learned.length === 0) return alert("B·∫°n ƒë√£ ho√†n th√†nh h·∫øt! Ch·ªù c·∫≠p nh·∫≠t th√™m.");
            // Pull random 10
             gameQueue = learned.sort(()=>0.5-Math.random()).slice(0,10).map(w=>({word:w, type:'practice'}));
             alert("Kh√¥ng c√≥ t·ª´ m·ªõi/c·∫ßn √¥n. Chuy·ªÉn sang ch·∫ø ƒë·ªô Luy·ªán t·∫≠p ng·∫´u nhi√™n.");
        } else {
            // Shuffle initial queue
            gameQueue.sort(() => Math.random() - 0.5);
        }
    } else {
        // Other modes (Quiz/Fill/Matching) uses randomized learned list
        const list = words.filter(w => srsData[getWordID(w)] || mode === 'flashcard'); // Flashcard shows all
        if(list.length < 4 && mode !== 'flashcard') return alert("C·∫ßn h·ªçc √≠t nh·∫•t 4 t·ª´ tr∆∞·ªõc khi ch∆°i!");
        gameQueue = list.map(w => ({ word: w, type: 'practice' })).sort(() => Math.random() - 0.5);
    }
    
    totalSessionItems = gameQueue.length; // Approximate for progress
    document.getElementById('gameOverlay').style.display = 'flex';
    document.getElementById('streakCounter').innerText = "üî• 0";
    
    // Start loop
    nextItem();
}

function refillQueue() {
    // Called when queue is empty in Smart Mode to create infinite feel
    if(currentMode !== 'smart') return false;
    
    const words = allTopics[currentTopicKey].words;
    const newBatch = words.filter(w => !srsData[getWordID(w)]).slice(0, 3)
                          .map(w => ({ word: w, type: 'new' }));
    
    if(newBatch.length > 0) {
        gameQueue.push(...newBatch);
        totalSessionItems += newBatch.length;
        alert("Tuy·ªát v·ªùi! ƒê√£ th√™m 3 t·ª´ m·ªõi ƒë·ªÉ ti·∫øp t·ª•c th·ª≠ th√°ch.");
        return true;
    }
    return false;
}

function nextItem() {
    // Hide feedback
    document.getElementById('feedbackSheet').classList.remove('show');
    
    if(gameQueue.length === 0) {
        if(!refillQueue()) {
            playSound('fanfare');
            showConfetti();
            setTimeout(() => {
                alert("Ho√†n th√†nh xu·∫•t s·∫Øc phi√™n h·ªçc! üéâ");
                quitGame();
            }, 2000);
            return;
        }
    }
    
    currentItem = gameQueue.shift(); // Take first
    updateProgress();
    
    const body = document.getElementById('gameBody');
    body.innerHTML = ''; // Clear
    
    // RENDER BASED ON MODE & RANDOMNESS IN SMART MODE
    let renderType = 'flashcard';
    if(currentMode === 'smart') {
        // Randomize types: 60% Flashcard, 20% Quiz, 20% Fill (if not new)
        const rand = Math.random();
        if(currentItem.type === 'new') renderType = 'flashcard';
        else if(rand < 0.6) renderType = 'flashcard';
        else if(rand < 0.8) renderType = 'quiz';
        else renderType = 'fill';
    } else {
        renderType = currentMode;
    }
    
    if(renderType === 'flashcard') renderFlashcardUI(body);
    else if(renderType === 'quiz') renderQuizUI(body);
    else if(renderType === 'fill') renderFillUI(body);
    else if(renderType === 'matching') renderMatchingUI(body);
}

function updateProgress() {
    // Formula: (Total - Remaining) / Total
    const done = totalSessionItems - gameQueue.length; // Rough estimate because queue grows on mistakes
    const pct = Math.min(100, (sessionCorrect / totalSessionItems) * 100);
    document.getElementById('gameProgress').style.width = pct + "%";
}

/**
 * --- ANSWER PROCESSING (SCIENTIFIC LOOP) ---
 */
function checkAnswer(isCorrect, correctAnswerText) {
    const sheet = document.getElementById('feedbackSheet');
    const title = document.getElementById('fbTitle');
    const msg = document.getElementById('fbMessage');
    const btn = document.getElementById('fbBtn');
    
    // UPDATE SRS DATA
    const id = getWordID(currentItem.word);
    let s = srsData[id] || { level: 0, interval: 0, nextReview: 0 };
    
    if(isCorrect) {
        playSound('correct');
        // Visuals
        showConfetti();
        streak++;
        document.getElementById('streakCounter').innerText = "üî• " + streak;
        
        // SRS Math
        if(currentItem.type !== 'practice') {
            if(s.level === 0) s.interval = 1;
            else if(s.level === 1) s.interval = 3;
            else s.interval = Math.ceil(s.interval * 2.2);
            s.level++;
            s.nextReview = Date.now() + (s.interval * 24 * 3600 * 1000);
            srsData[id] = s;
            localStorage.setItem('srs_db_v3', JSON.stringify(srsData));
        }
        
        // UI Feedback - Auto Advance
        sheet.className = 'correct show'; // Slide up green
        title.innerText = "Tuy·ªát v·ªùi!";
        msg.innerText = "";
        btn.className = "btn-3d btn-success";
        
        sessionCorrect++;
        
        // Auto continue after 1.5s
        window.autoTimer = setTimeout(nextItem, 1200);
        
    } else {
        // WRONG
        playSound('wrong');
        document.getElementById('gameBody').classList.add('shake-anim');
        setTimeout(()=>document.getElementById('gameBody').classList.remove('shake-anim'), 500);
        
        streak = 0;
        document.getElementById('streakCounter').innerText = "üî• 0";
        
        // SRS Reset
        if(currentItem.type !== 'practice') {
            s.level = 0;
            s.interval = 0;
            s.nextReview = Date.now(); // Review now
            srsData[id] = s;
            localStorage.setItem('srs_db_v3', JSON.stringify(srsData));
            
            // QUEUE LOGIC: Push back to queue to review again in THIS session
            // Insert at index 3 or end, so it doesn't appear immediately
            let insertIdx = Math.min(gameQueue.length, 2);
            gameQueue.splice(insertIdx, 0, currentItem); 
        }
        
        // UI Feedback - Manual Continue
        sheet.className = 'wrong show';
        title.innerText = "Ch∆∞a ch√≠nh x√°c";
        msg.innerHTML = `ƒê√°p √°n ƒë√∫ng l√†: <strong style="color:var(--primary)">${correctAnswerText}</strong>`;
        btn.className = "btn-3d btn-error";
        
        // Cancel any auto timer
        clearTimeout(window.autoTimer);
    }
}

function handleFeedbackContinue() {
    nextItem();
}

/**
 * --- RENDERERS ---
 */
// 1. FLASHCARD RENDER
let isFlipped = false;
function renderFlashcardUI(container) {
    const w = currentItem.word;
    isFlipped = false;
    container.innerHTML = `
        <div class="scene">
            <div class="card" onclick="this.classList.toggle('is-flipped'); isFlipped=!isFlipped; if(isFlipped) speak('${w.english}')">
                <div class="card__face card__face--front">
                    <div style="font-size:0.9rem; color:var(--text-sub); margin-bottom:10px;">TI·∫æNG ANH (Ch·∫°m ƒë·ªÉ l·∫≠t)</div>
                    <div class="word-en">${w.english}</div>
                    <div class="word-ipa">${w.ipa || ''}</div>
                    <button class="btn-3d btn-icon" style="margin-top:20px;" onclick="event.stopPropagation(); speak('${w.english}')"><i class="fas fa-volume-up"></i></button>
                </div>
                <div class="card__face card__face--back">
                     <div style="font-size:0.9rem; color:var(--text-sub); margin-bottom:10px;">TI·∫æNG VI·ªÜT</div>
                    <div class="word-vn">${w.vietnamese}</div>
                    <div style="margin-top:15px; font-style:italic;">"${w.example || ''}"</div>
                </div>
            </div>
        </div>
        <div style="display:flex; gap:20px; width:100%; max-width:400px;">
            <button class="btn-3d btn-error" style="flex:1" onclick="checkAnswer(false, '${w.vietnamese}')">Qu√™n</button>
            <button class="btn-3d btn-success" style="flex:1" onclick="checkAnswer(true, '${w.vietnamese}')">ƒê√£ nh·ªõ</button>
        </div>
    `;
    setTimeout(() => speak(w.english), 300);
}

// 2. QUIZ RENDER
function renderQuizUI(container) {
    const w = currentItem.word;
    const words = allTopics[currentTopicKey].words;
    // Generate distractors
    let distractors = words.filter(x => x.english !== w.english)
                           .sort(() => Math.random()-0.5).slice(0,3);
    let options = [...distractors, w].sort(()=>Math.random()-0.5);
    
    let html = `
        <div style="margin-bottom:30px; text-align:center;">
             <div style="color:var(--text-sub)">Ch·ªçn nghƒ©a c·ªßa t·ª´:</div>
             <h1 style="color:var(--primary); font-size:2.5rem;">${w.english}</h1>
             <button class="btn-3d btn-icon" onclick="speak('${w.english}')"><i class="fas fa-volume-up"></i></button>
        </div>
        <div style="display:grid; grid-template-columns:1fr; gap:15px; width:100%; max-width:400px;">
    `;
    
    options.forEach(opt => {
        html += `<button class="btn-3d" onclick="checkAnswer(${opt.english===w.english}, '${w.vietnamese}')">${opt.vietnamese}</button>`;
    });
    html += `</div>`;
    container.innerHTML = html;
    speak(w.english);
}

// 3. FILL RENDER
function renderFillUI(container) {
    const w = currentItem.word;
    const sentence = w.example || `The word is ${w.english}`;
    const masked = sentence.replace(new RegExp(w.english, 'gi'), '_____');
    
    container.innerHTML = `
        <div style="background:white; padding:20px; border-radius:15px; border:2px solid #eee; margin-bottom:20px; width:100%; text-align:center;">
            <div style="font-size:1.2rem; color:var(--text-main); margin-bottom:10px;">${masked}</div>
            <div style="font-size:0.9rem; color:var(--text-sub)">(${w.vietnamese})</div>
        </div>
        <input type="text" id="fillInp" class="input-ui" placeholder="Nh·∫≠p t·ª´ ti·∫øng Anh..." autocomplete="off">
        <button class="btn-3d btn-primary" style="width:100%; margin-top:20px;" onclick="handleFillCheck()">KI·ªÇM TRA</button>
    `;
    
    // Focus input
    setTimeout(() => document.getElementById('fillInp').focus(), 100);
}

function handleFillCheck() {
    const val = document.getElementById('fillInp').value.trim();
    const correct = currentItem.word.english;
    checkAnswer(val.toLowerCase() === correct.toLowerCase(), correct);
}

// 4. MATCHING (MINI GAME INSIDE LOOP - TRICKY IN QUEUE, SIMPLIFY)
// For Matching in Smart Loop, we just pick 4 pairs including the current one + 3 others.
function renderMatchingUI(container) {
    // Matching is handled differently: it resolves the current item immediately if solved, 
    // but usually Matching implies a set. In Smart Mode, better to avoid heavy matching 
    // or treat it as a "Bonus Round". Let's stick to 1-pair identification or small grid.
    // Simplifying: Show 3 English, 3 Vietnamese side by side mixed.
    
    // Actually, let's skip matching in Smart Loop to keep flow fast.
    // If specifically selected 'matching' mode:
    if(currentMode === 'matching') {
        setupMatchingGrid(container);
        return;
    }
    // If smart mode hit 'matching' case (rare), fallback to Quiz
    renderQuizUI(container);
}

function setupMatchingGrid(container) {
    // Take 4 pairs from queue (or generate if queue small)
    let set = gameQueue.slice(0, 4);
    if(set.length < 4) {
         // Not enough in queue, borrow from pool
         const words = allTopics[currentTopicKey].words;
         const extras = words.filter(w => !set.includes(w)).sort(()=>Math.random()).slice(0, 4-set.length);
         set = [...set, ...extras.map(w=>({word:w}))];
    }
    
    let items = [];
    set.forEach((obj, idx) => {
        items.push({ txt: obj.word.english, id: idx, type: 'en' });
        items.push({ txt: obj.word.vietnamese, id: idx, type: 'vn' });
    });
    items.sort(() => Math.random() - 0.5);
    
    let html = `<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; width:100%;">`;
    items.forEach((item, i) => {
        html += `<div id="match-${i}" class="btn-3d" style="font-size:0.9rem; padding:10px;" onclick="matchClick(${i}, ${item.id})">${item.txt}</div>`;
    });
    html += `</div>`;
    container.innerHTML = html;
    
    window.matchState = { selected: null, solved: 0, total: set.length };
}

window.matchClick = function(idx, id) {
    const el = document.getElementById(`match-${idx}`);
    if(el.style.opacity === '0') return;
    
    const s = window.matchState;
    el.style.borderColor = 'var(--primary)';
    
    if(!s.selected) {
        s.selected = { idx, id, el };
    } else {
        if(s.selected.idx === idx) return; // Click same
        
        if(s.selected.id === id) {
            // Correct
            el.style.backgroundColor = 'var(--success)'; el.style.borderColor = 'var(--success)';
            s.selected.el.style.backgroundColor = 'var(--success)'; s.selected.el.style.borderColor = 'var(--success)';
            playSound('correct');
            setTimeout(() => {
                el.style.opacity = 0; s.selected.el.style.opacity = 0;
            }, 300);
            s.solved++;
            if(s.solved === s.total) {
                setTimeout(() => {
                    alert("Ho√†n th√†nh m√†n gh√©p ƒë√¥i!");
                    quitGame();
                }, 800);
            }
        } else {
            // Wrong
            el.style.backgroundColor = 'var(--error)';
            s.selected.el.style.backgroundColor = 'var(--error)';
            playSound('wrong');
            setTimeout(() => {
                el.style.backgroundColor = 'var(--surface)'; el.style.borderColor = '#d1d8e0';
                s.selected.el.style.backgroundColor = 'var(--surface)'; s.selected.el.style.borderColor = '#d1d8e0';
            }, 500);
        }
        s.selected = null;
    }
}

/**
 * --- UTILS ---
 */
function quitGame() {
    clearTimeout(window.autoTimer);
    document.getElementById('gameOverlay').style.display = 'none';
    updateDashboard(); // Refresh stats
}

function showConfetti() {
    const colors = ['#ff9f43', '#54a0ff', '#1dd1a1', '#ff6b6b'];
    for(let i=0; i<30; i++) {
        const c = document.createElement('div');
        c.className = 'confetti';
        c.style.left = Math.random() * 100 + 'vw';
        c.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
        c.style.animationDuration = (Math.random()*2 + 1) + 's';
        document.body.appendChild(c);
        setTimeout(() => c.remove(), 3000);
    }
}

function setupVoices() {
    const sel = document.getElementById('voiceSelect');
    const voices = window.speechSynthesis.getVoices();
    if(voices.length === 0) { window.speechSynthesis.onvoiceschanged = setupVoices; return; }
    
    sel.innerHTML = '';
    voices.filter(v=>v.lang.includes('en')).forEach(v => {
        const opt = document.createElement('option');
        opt.value = v.voiceURI;
        opt.innerText = v.name;
        if(v.voiceURI === selectedVoiceURI) opt.selected = true;
        sel.appendChild(opt);
    });
    sel.onchange = () => {
        selectedVoiceURI = sel.value;
        localStorage.setItem('voice_uri', selectedVoiceURI);
    };
}

function speak(txt) {
    window.speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(txt);
    const v = window.speechSynthesis.getVoices().find(x => x.voiceURI === selectedVoiceURI);
    if(v) u.voice = v;
    u.rate = 0.9;
    window.speechSynthesis.speak(u);
}

</script>
</body>
</html>
