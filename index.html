<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flashcard Pro - GitHub Sync</title>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<style>
  :root {
    --bg-color: #f0f4f8; /* N·ªÅn s√°ng */
    --card-color: #f0f4f8;
    --text-main: #2d3436;
    --text-sub: #636e72;
    --accent: #4834d4; /* M√†u t√≠m ƒë·∫≠m */
    --accent-hover: #686de0;
    --shadow-light: #ffffff;
    --shadow-dark: #d1d9e6;
    --success: #2ecc71; /* Xanh l√° */
    --error: #e74c3c; /* ƒê·ªè */
    --warning: #f1c40f; /* V√†ng */
  }

  * { box-sizing: border-box; margin: 0; padding: 0; outline: none; }
  
  body {
    font-family: 'Segoe UI', Roboto, sans-serif;
    background: var(--bg-color);
    color: var(--text-main);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding-bottom: 80px;
  }

  /* --- NEUMORPHISM UTILS --- */
  .neu-box {
    background: var(--card-color);
    border-radius: 20px;
    box-shadow: 6px 6px 12px var(--shadow-dark), -6px -6px 12px var(--shadow-light);
    border: 1px solid rgba(255,255,255,0.4);
  }

  .neu-btn {
    border: none;
    background: var(--card-color);
    color: var(--accent);
    font-weight: 700;
    padding: 12px 24px;
    border-radius: 50px;
    box-shadow: 5px 5px 10px var(--shadow-dark), -5px -5px 10px var(--shadow-light);
    cursor: pointer;
    transition: all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-size: 0.9rem;
  }
  .neu-btn:hover { transform: translateY(-2px); color: var(--accent-hover); }
  .neu-btn:active {
    box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
    transform: translateY(1px);
  }
  .neu-btn.mastered { background-color: var(--success); color: white; }
  .neu-btn.incorrect { background-color: var(--error); color: white; }
  .neu-btn.correct { background-color: var(--success); color: white; }


  .neu-input, .neu-select {
    width: 100%;
    padding: 12px 20px;
    border-radius: 15px;
    border: none;
    background: var(--bg-color);
    box-shadow: inset 4px 4px 8px var(--shadow-dark), inset -4px -4px 8px var(--shadow-light);
    color: var(--text-main);
    font-size: 1rem;
  }

  /* --- HEADER & REPO CONFIG --- */
  header {
    text-align: center;
    margin-top: 40px;
    margin-bottom: 30px;
    width: 90%;
    max-width: 600px;
  }
  h1 { font-size: 2.5rem; color: var(--accent); margin-bottom: 10px; }
  
  .config-panel {
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  .input-group { display: flex; gap: 10px; }
  
  /* --- TOPIC GRID --- */
  .grid-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 25px;
    width: 90%;
    max-width: 1000px;
    padding-bottom: 50px;
  }
  .topic-card {
    padding: 25px;
    cursor: pointer;
    transition: transform 0.3s;
    text-align: center;
    position: relative;
    border-left: 5px solid transparent;
  }
  .topic-card.active { border-left: 5px solid var(--accent); }
  .topic-card:hover { transform: translateY(-5px); }
  .topic-title { font-size: 1.2rem; font-weight: bold; margin-bottom: 5px; }
  .topic-meta { font-size: 0.9rem; color: var(--text-sub); }

  /* --- GAME OVERLAY --- */
  #gameOverlay {
    position: fixed; inset: 0;
    background: var(--bg-color);
    z-index: 1000;
    display: none;
    flex-direction: column;
    align-items: center;
    overflow-y: auto;
    padding-bottom: 50px;
  }
  
  .game-header {
    width: 100%; padding: 20px;
    display: flex; justify-content: space-between; align-items: center;
  }
  .close-btn { color: var(--error); width: 40px; height: 40px; display: grid; place-items: center; font-size: 1.5rem; border-radius: 50%; cursor: pointer; }

  /* --- FLASHCARD SPECIFIC --- */
  .scene {
    width: 320px; height: 450px;
    perspective: 1000px;
    margin: 20px auto;
  }
  .card {
    width: 100%; height: 100%;
    position: relative;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    cursor: pointer;
  }
  .card.is-flipped { transform: rotateY(180deg); }
  
  .card__face {
    position: absolute;
    width: 100%; height: 100%;
    backface-visibility: hidden;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding: 20px;
    text-align: center;
    background: var(--card-color);
    box-shadow: 10px 10px 20px var(--shadow-dark), -10px -10px 20px var(--shadow-light);
    border: 2px solid rgba(255,255,255,0.1);
  }
  
  .card__face--back { transform: rotateY(180deg); border-color: var(--accent); }

  /* Card Content */
  .word-en { font-size: 3rem; font-weight: 800; color: var(--accent); margin-bottom: 10px; }
  .word-ipa { font-size: 1.1rem; color: #888; font-style: italic; font-family: 'Times New Roman', serif; margin-bottom: 20px;}
  .word-vn { font-size: 2rem; font-weight: 700; color: var(--text-main); }
  .word-example { font-size: 1rem; color: var(--text-sub); margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.03); border-radius: 10px; }
  .ordinal-badge {
    position: absolute; top: 15px; right: 15px;
    background: var(--accent); color: white;
    padding: 5px 10px; border-radius: 10px; font-size: 0.8rem;
  }
  
  .mastered-btn-area {
    width: 100%; display: flex; justify-content: center; margin-top: 15px;
  }
  /* --- TTS CONTROLS --- */
  .tts-controls {
    display: flex; gap: 10px; align-items: center;
    margin-bottom: 20px;
    justify-content: center; /* Th√™m cƒÉn gi·ªØa */
  }
  .tts-btn {
    border: none;
    background: var(--accent);
    color: white;
    padding: 10px 15px;
    border-radius: 50px;
    cursor: pointer;
    transition: background 0.2s;
    font-size: 0.9rem;
  }
  .tts-btn:hover { background: var(--accent-hover); }

  /* --- GAME CONTENT WRAPPER --- */
  #gameContent {
    width: 90%; max-width: 600px; margin: 20px auto;
    display: flex; flex-direction: column; align-items: center;
  }

  /* --- FILL IN THE BLANK SPECIFIC --- */
  .fill-sentence { font-size: 1.4rem; text-align: center; margin-bottom: 20px; padding: 0 10px; }
  .fill-input-area { display: flex; gap: 10px; width: 100%; justify-content: center; margin-top: 15px; }

  /* --- MATCHING SPECIFIC --- */
  .matching-grid {
    display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 100%; max-width: 500px;
  }
  .match-btn {
    padding: 15px; font-size: 1rem; text-align: center;
    background: var(--card-color); border-radius: 15px;
    box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
    cursor: pointer; transition: all 0.1s;
    height: 60px; /* Chi·ªÅu cao c·ªë ƒë·ªãnh */
    display: flex; align-items: center; justify-content: center;
    word-break: break-word;
  }
  .match-btn.selected { border: 3px solid var(--accent); box-shadow: 0 0 15px var(--accent); }
  .match-btn.matched { background: var(--success); color: white; pointer-events: none; }
  .match-btn.mismatch { background: var(--error); color: white; pointer-events: none; }
  
  /* --- QUIZ SPECIFIC --- */
  .quiz-question { font-size: 1.5rem; text-align: center; margin-bottom: 30px; font-weight: bold; }
  .quiz-options-grid { display: grid; grid-template-columns: 1fr; gap: 15px; width: 100%; }
  .quiz-option-btn { padding: 15px; font-size: 1.1rem; }
  
</style>
</head>
<body>

<header>
  <h1>H·ªçc T·ª´ V·ª±ng</h1>
  
  <div class="neu-box config-panel">
    <div style="font-size:0.9rem; color:var(--accent); margin-bottom:5px;">K·∫øt n·ªëi GitHub:</div>
    <div class="input-group">
      <input type="text" id="gh-user" class="neu-input" placeholder="Username (VD: octocat)" value="ngxuanhai123">
      <input type="text" id="gh-repo" class="neu-input" placeholder="Repository (VD: tu-vung)" value="tuvung">
    </div>
    <button class="neu-btn" style="justify-content:center; width:100%" onclick="fetchTopics()">
      <i class="fas fa-cloud-download-alt"></i> T·∫£i d·ªØ li·ªáu
    </button>
    <div id="status-msg" style="font-size:0.8rem; color:var(--text-sub);">Vui l√≤ng b·∫•m T·∫£i d·ªØ li·ªáu ho·∫∑c ch·ªù 3 gi√¢y ƒë·ªÉ t·ª± ƒë·ªông t·∫£i.</div>
  </div>
</header>

<div id="topicList" class="grid-container">
  <div style="grid-column: 1/-1; text-align: center; color: var(--text-sub); margin-top: 50px;">
    ƒêang t·∫£i d·ªØ li·ªáu t·ª´ GitHub...
  </div>
</div>

<div class="game-bar" style="position:fixed; bottom:0; left:0; right:0; background:var(--bg-color); padding:15px; display:flex; justify-content:center; gap:10px; box-shadow:0 -5px 15px rgba(0,0,0,0.1);">
  <button class="neu-btn" onclick="startGame('flashcard')"><i class="fas fa-layer-group"></i> Flashcard</button>
  <button class="neu-btn" onclick="startGame('fill')"><i class="fas fa-font"></i> ƒêi·ªÅn t·ª´</button>
  <button class="neu-btn" onclick="startGame('matching')"><i class="fas fa-exchange-alt"></i> Gh√©p ƒë√¥i</button>
  <button class="neu-btn" onclick="startGame('quiz')"><i class="fas fa-check-square"></i> Tr·∫Øc nghi·ªám</button>
</div>

<div id="gameOverlay">
  <div class="game-header">
    <h2 id="gameTitle" style="color:var(--accent)">Ch·ªß ƒë·ªÅ</h2>
    <div style="display:flex; gap:10px; align-items:center;">
      <label for="speedRate" style="font-size:0.9rem; font-weight:bold;">T·ªëc ƒë·ªô:</label>
      <select id="speedRate" class="neu-select" style="width: 80px; height: 35px; padding: 5px;">
        <option value="0.75">0.75x</option>
        <option value="1" selected>1.0x</option>
        <option value="1.25">1.25x</option>
      </select>
      <div class="neu-box close-btn" onclick="closeGame()"><i class="fas fa-times"></i></div>
    </div>
  </div>
  
  <div id="gameContent">
    </div>

  <div class="controls-area" style="display:flex; gap:20px; margin-top:30px;">
    <button class="neu-btn" id="btnPrev" onclick="prevCard()"><i class="fas fa-arrow-left"></i> Tr∆∞·ªõc</button>
    <span id="cardCounter" style="font-weight:bold; font-size:1.2rem; align-self:center;">0/0</span>
    <button class="neu-btn" id="btnNext" onclick="nextCard()">Sau <i class="fas fa-arrow-right"></i></button>
  </div>
</div>

<script>
  // --- VARIABLES & STORAGE ---
  let allTopics = {};
  let currentTopicKey = null;
  let currentWords = [];
  let currentMode = '';
  let currentIndex = 0;
  
  // Storage keys
  const STORAGE_KEY_MASTERED = 'flashcard_mastered_v2'; // Thay ƒë·ªïi key ƒë·ªÉ tr√°nh xung ƒë·ªôt
  const STORAGE_KEY_HISTORY = 'flashcard_history_v2'; // Thay ƒë·ªïi key ƒë·ªÉ tr√°nh xung ƒë·ªôt
  
  // T·∫£i d·ªØ li·ªáu l·ªãch s·ª≠ ƒë√£ h·ªçc v√† t·ª´ ƒë√£ thu·ªôc
  let masteredWords = JSON.parse(localStorage.getItem(STORAGE_KEY_MASTERED) || '{}');
  let historyWords = JSON.parse(localStorage.getItem(STORAGE_KEY_HISTORY) || '{}'); // { "word_key": timestamp_ms }

  // --- UTILS ---
  function closeGame() {
    document.getElementById('gameOverlay').style.display = 'none';
    window.speechSynthesis.cancel(); // D·ª´ng ƒë·ªçc khi tho√°t game
    renderTopicList(); // C·∫≠p nh·∫≠t l·∫°i s·ªë t·ª´ ch∆∞a thu·ªôc
  }

  function getWordKey(word) {
      // D√πng english + 3 k√Ω t·ª± ƒë·∫ßu c·ªßa vietnamese ƒë·ªÉ l√†m key duy nh·∫•t
      const en = (word.english || '').replace(/\s/g, '').toLowerCase();
      const vn = (word.vietnamese || '').substring(0, 3).replace(/\s/g, '').toLowerCase();
      return `${en}_${vn}`;
  }

  function getUniqueWords(words) {
      // Lo·∫°i b·ªè c√°c t·ª´ ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u Mastered
      return words.filter(word => {
          const key = getWordKey(word);
          return !masteredWords[key];
      });
  }

  // --- GITHUB FETCHING ---
  window.onload = () => {
    // T·ª± ƒë·ªông s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu ch∆∞a l∆∞u trong localStorage
    if(!localStorage.getItem('gh_user')) localStorage.setItem('gh_user', document.getElementById('gh-user').value);
    if(!localStorage.getItem('gh_repo')) localStorage.setItem('gh_repo', document.getElementById('gh-repo').value);
    
    // Load l·∫°i gi√° tr·ªã ƒë√£ l∆∞u n·∫øu c√≥
    document.getElementById('gh-user').value = localStorage.getItem('gh_user');
    document.getElementById('gh-repo').value = localStorage.getItem('gh_repo');
    
    // T·ª± ƒë·ªông t·∫£i d·ªØ li·ªáu
    setTimeout(() => {
        fetchTopics();
    }, 100);
  };

  async function fetchTopics() {
    const user = document.getElementById('gh-user').value.trim();
    const repo = document.getElementById('gh-repo').value.trim();
    const status = document.getElementById('status-msg');
    const listDiv = document.getElementById('topicList');

    if(!user || !repo) {
      status.style.color = 'var(--error)';
      status.innerText = "Vui l√≤ng nh·∫≠p ƒë·ªß User v√† Repo!";
      listDiv.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-sub); margin-top: 50px;">Vui l√≤ng nh·∫≠p Github Info v√† b·∫•m "T·∫£i d·ªØ li·ªáu" ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>';
      return;
    }

    localStorage.setItem('gh_user', user);
    localStorage.setItem('gh_repo', repo);

    status.style.color = 'var(--text-sub)';
    status.innerText = "ƒêang k·∫øt n·ªëi GitHub...";
    listDiv.innerHTML = '<div class="neu-box" style="grid-column: 1/-1; padding:20px; text-align:center;">ƒêang t·∫£i danh s√°ch file...</div>';
    allTopics = {};

    try {
      const apiURL = `https://api.github.com/repos/${user}/${repo}/contents/`;
      const res = await fetch(apiURL);
      if(!res.ok) throw new Error(`L·ªói ${res.status}: Kh√¥ng t√¨m th·∫•y Repo ho·∫∑c l·ªói m·∫°ng. (URL: ${apiURL})`);
      const files = await res.json();
      const jsonFiles = files.filter(f => f.name.endsWith('.json')).sort((a,b) => a.name.localeCompare(b.name));

      if (jsonFiles.length === 0) {
        listDiv.innerHTML = '<div style="grid-column: 1/-1; text-align:center;">Kh√¥ng t√¨m th·∫•y file .json n√†o trong repo n√†y.</div>';
        status.innerText = "Repo kh√¥ng c√≥ file .json.";
        return;
      }

      // T·∫£i v√† l∆∞u tr·ªØ n·ªôi dung t·ª´ng file
      for (const file of jsonFiles) {
        const raw = await fetch(file.download_url);
        const data = await raw.json();
        
        let words = [];
        if (data.words && Array.isArray(data.words)) {
            words = data.words;
        } else if (Array.isArray(data)) {
            words = data;
        }
        
        if (words.length > 0) {
            allTopics[file.name] = {
                name: data.name || formatName(file.name),
                words: words,
                url: file.download_url
            };
        }
      }
      
      renderTopicList();
      status.innerText = `T·∫£i th√†nh c√¥ng ${Object.keys(allTopics).length} ch·ªß ƒë·ªÅ.`;
      
      // T·ª± ƒë·ªông ch·ªçn ch·ªß ƒë·ªÅ ƒë·∫ßu ti√™n sau khi t·∫£i xong
      if (Object.keys(allTopics).length > 0) {
        autoSelectTopic();
      }

    } catch (err) {
      console.error(err);
      status.style.color = 'var(--error)';
      status.innerText = "L·ªói: " + err.message;
      listDiv.innerHTML = `<div style="grid-column: 1/-1; text-align:center; color:var(--error)">Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Ki·ªÉm tra l·∫°i t√™n User/Repo.</div>`;
    }
  }
  
  function formatName(filename) {
    return filename.replace('.json', '').replace(/[-_]/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  }
  
  function renderTopicList() {
      const listDiv = document.getElementById('topicList');
      listDiv.innerHTML = '';
      const keys = Object.keys(allTopics).sort(); // S·∫Øp x·∫øp theo t√™n file
      
      if(keys.length === 0) {
          listDiv.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-sub); margin-top: 50px;">Kh√¥ng c√≥ ch·ªß ƒë·ªÅ n√†o ƒë∆∞·ª£c t·∫£i.</div>';
          return;
      }
      
      keys.forEach(key => {
          const topic = allTopics[key];
          const wordsCount = topic.words.length;
          const uniqueCount = getUniqueWords(topic.words).length;
          const div = document.createElement('div');
          div.className = `neu-box topic-card ${key === currentTopicKey ? 'active' : ''}`;
          div.innerHTML = `
            <div class="topic-title">${topic.name}</div>
            <div class="topic-meta">(${uniqueCount}/${wordsCount} t·ª´ ch∆∞a thu·ªôc)</div>
          `;
          div.onclick = () => manualSelectTopic(key);
          listDiv.appendChild(div);
      });
  }

  function manualSelectTopic(key) {
      currentTopicKey = key;
      renderTopicList();
      document.getElementById('status-msg').style.color = 'var(--accent)';
      document.getElementById('status-msg').innerText = `ƒê√£ ch·ªçn: ${allTopics[key].name}. B·∫•m n√∫t ch∆°i game ƒë·ªÉ b·∫Øt ƒë·∫ßu!`;
  }

  function autoSelectTopic() {
      const keys = Object.keys(allTopics).sort();
      if (keys.length > 0) {
          const lastTopicKey = localStorage.getItem('last_topic_key');
          let nextKey = keys[0]; // M·∫∑c ƒë·ªãnh l√† ch·ªß ƒë·ªÅ ƒë·∫ßu ti√™n
          
          if (lastTopicKey && keys.includes(lastTopicKey)) {
              // T√¨m ch·ªß ƒë·ªÅ ti·∫øp theo ch·ªâ khi ch·ªß ƒë·ªÅ tr∆∞·ªõc ƒë√£ thu·ªôc h·∫øt
              const lastTopic = allTopics[lastTopicKey];
              if (getUniqueWords(lastTopic.words).length === 0) {
                  const lastIndex = keys.indexOf(lastTopicKey);
                  nextKey = keys[(lastIndex + 1) % keys.length]; // Ch·ªß ƒë·ªÅ ti·∫øp theo
              } else {
                  nextKey = lastTopicKey; // Ti·∫øp t·ª•c v·ªõi ch·ªß ƒë·ªÅ c≈© n·∫øu ch∆∞a h·ªçc xong
              }
          }
          
          currentTopicKey = nextKey;
          localStorage.setItem('last_topic_key', currentTopicKey);
          renderTopicList();
          document.getElementById('status-msg').style.color = 'var(--accent)';
          document.getElementById('status-msg').innerText = `T·ª± ƒë·ªông ch·ªçn ch·ªß ƒë·ªÅ: ${allTopics[currentTopicKey].name}.`;
      }
  }

  // --- GAME INITIALIZATION & CONTROL ---
  function startGame(mode) {
    if (!currentTopicKey) {
      alert("Vui l√≤ng t·∫£i d·ªØ li·ªáu t·ª´ GitHub v√† ch·ªçn ch·ªß ƒë·ªÅ tr∆∞·ªõc!");
      return;
    }
    
    currentMode = mode;
    const allWords = allTopics[currentTopicKey].words;
    
    // Lo·∫°i tr·ª´ t·ª´ ƒë√£ thu·ªôc
    currentWords = getUniqueWords(allWords);
    
    if (currentWords.length === 0) {
        alert("Tuy·ªát v·ªùi! B·∫°n ƒë√£ thu·ªôc h·∫øt t·ª´ v·ª±ng trong ch·ªß ƒë·ªÅ n√†y. ƒêang chuy·ªÉn sang ch·ªß ƒë·ªÅ ti·∫øp theo.");
        autoSelectTopic();
        // Ki·ªÉm tra l·∫°i sau khi chuy·ªÉn ch·ªß ƒë·ªÅ
        if (getUniqueWords(allTopics[currentTopicKey].words).length === 0) {
            alert("B·∫°n ƒë√£ h·ªçc h·∫øt t·∫•t c·∫£ c√°c ch·ªß ƒë·ªÅ!");
            return;
        }
        startGame(mode); // Th·ª≠ load game v·ªõi ch·ªß ƒë·ªÅ m·ªõi
        return;
    }

    document.getElementById('gameOverlay').style.display = 'flex';
    document.getElementById('gameTitle').innerText = `${allTopics[currentTopicKey].name} - ${getModeName(mode)}`;

    // T·∫£i n·ªôi dung game c·ª• th·ªÉ
    if (mode === 'flashcard') {
      setupFlashcard();
    } else if (mode === 'fill') {
      setupFillInTheBlank();
    } else if (mode === 'matching') {
      setupMatching();
    } else if (mode === 'quiz') {
      setupSmartQuiz(allWords); // Quiz th√¥ng minh c·∫ßn c·∫£ danh s√°ch ƒë√£ thu·ªôc v√† ch∆∞a thu·ªôc ƒë·ªÉ l√†m distractors
    }
    
    // ·∫®n/Hi·ªán n√∫t ƒëi·ªÅu h∆∞·ªõng (ch·ªâ c·∫ßn cho Flashcard v√† Fill)
    const displayControls = (mode === 'flashcard' || mode === 'fill');
    const controlsArea = document.querySelector('.controls-area');
    if (displayControls) {
        controlsArea.style.display = 'flex';
    } else {
        controlsArea.style.display = 'none';
    }
  }
  
  function getModeName(mode) {
      switch(mode) {
          case 'flashcard': return 'Flashcard';
          case 'fill': return 'ƒêi·ªÅn t·ª´';
          case 'matching': return 'Gh√©p ƒë√¥i';
          case 'quiz': return 'Tr·∫Øc nghi·ªám';
          default: return 'Game';
      }
  }

  // --- FLASHCARD & FILL IN THE BLANK LOGIC ---
  let isFlipped = false;
  
  function setupFlashcard() {
    const content = document.getElementById('gameContent');
    content.innerHTML = `
      <div class="scene">
        <div class="card" id="flashcard" onclick="flipCard()">
          <div class="card__face card__face--front">
            <div class="ordinal-badge" id="cardOrdinal"></div>
            <div class="word-en" id="textEn"></div>
            <div class="word-ipa" id="textIpa"></div>
            <div style="font-size:0.8rem; color:#aaa; margin-top:20px;">(Ch·∫°m ƒë·ªÉ l·∫≠t)</div>
          </div>
          <div class="card__face card__face--back">
            <div class="word-vn" id="textVn"></div>
            <div class="word-example" id="textEx"></div>
            <div id="textOrdinalVn" style="margin-top:10px; font-size:0.9rem; color:var(--accent)"></div>
          </div>
        </div>
      </div>
      <div class="tts-controls">
          <button class="tts-btn neu-box" onclick="speakCurrentWord()"><i class="fas fa-volume-up"></i> Ph√°t √¢m (V)</button>
      </div>
      <div class="mastered-btn-area">
          <button class="neu-btn" style="background-color: var(--warning); color: var(--text-main);" onclick="toggleMastered(currentWords[currentIndex])"><i class="fas fa-bookmark"></i> ƒê√°nh d·∫•u ƒê√£ thu·ªôc</button>
      </div>
    `;
    currentIndex = 0;
    renderFlashcard();
  }
  
  function setupFillInTheBlank() {
      const content = document.getElementById('gameContent');
      content.innerHTML = `
          <div class="tts-controls">
              <button class="tts-btn neu-box" onclick="speakCurrentWord()"><i class="fas fa-volume-up"></i> Ph√°t √¢m (V)</button>
          </div>
          <div class="fill-sentence" id="fillSentence"></div>
          <div class="fill-input-area">
              <input type="text" id="fillInput" class="neu-input" placeholder="Nh·∫≠p t·ª´ c√≤n thi·∫øu (Ti·∫øng Anh)" onkeydown="if(event.key === 'Enter') checkFillInTheBlank()">
              <button class="neu-btn" style="width: 100px; color:white; background-color: var(--accent);" onclick="checkFillInTheBlank()"><i class="fas fa-check"></i> Check</button>
          </div>
          <div id="fillResult" style="margin-top: 15px; font-weight: bold;"></div>
          <div id="fillAnswer" style="margin-top: 10px; font-size: 1.1rem; color: var(--text-main);"></div>
          <div class="mastered-btn-area">
              <button class="neu-btn" style="background-color: var(--warning); color: var(--text-main);" onclick="toggleMastered(currentWords[currentIndex])"><i class="fas fa-bookmark"></i> ƒê√°nh d·∫•u ƒê√£ thu·ªôc</button>
          </div>
      `;
      currentIndex = 0;
      renderFillInTheBlank();
  }

  function renderFlashcard() {
    const w = currentWords[currentIndex];
    isFlipped = false;
    document.getElementById('flashcard').classList.remove('is-flipped');

    document.getElementById('textEn').innerText = w.english || "???";
    document.getElementById('textIpa').innerText = w.ipa || "";
    document.getElementById('cardOrdinal').style.display = w.ordinal ? 'block' : 'none';
    document.getElementById('cardOrdinal').innerText = w.ordinal || "";

    document.getElementById('textVn').innerText = w.vietnamese || "Ch∆∞a c√≥ nghƒ©a";
    document.getElementById('textEx').innerText = w.example || "Kh√¥ng c√≥ v√≠ d·ª•";
    document.getElementById('textOrdinalVn').innerText = w.ordinal_vn ? `(${w.ordinal_vn})` : "";
    
    document.getElementById('cardCounter').innerText = `${currentIndex + 1}/${currentWords.length}`;
  }
  
  function renderFillInTheBlank() {
      const w = currentWords[currentIndex];
      const sentence = w.example || `D·ªãch t·ª´: ${w.vietnamese}`;
      const englishWord = w.english || '';
      
      let blankedSentence = sentence;
      if (englishWord) {
          // Thay th·∫ø t·ª´ ti·∫øng Anh b·∫±ng d·∫•u ch·∫•m
          // D√πng regex ƒë·ªÉ thay th·∫ø (bao g·ªìm c·∫£ tr∆∞·ªùng h·ª£p c√≥ d·∫•u ch·∫•m, ph·∫©y...)
          const cleanEnglishWord = englishWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          blankedSentence = sentence.replace(new RegExp(`\\b${cleanEnglishWord}(?:[\\.,!?:;])?\\b`, 'gi'), '_____');
      }
      
      document.getElementById('fillSentence').innerHTML = `<i class="fas fa-quote-left" style="color:var(--accent);"></i> ${blankedSentence} <i class="fas fa-quote-right" style="color:var(--accent);"></i>`;
      document.getElementById('fillInput').value = '';
      document.getElementById('fillResult').innerText = '';
      document.getElementById('fillAnswer').innerText = '';
      document.getElementById('cardCounter').innerText = `${currentIndex + 1}/${currentWords.length}`;
      document.getElementById('fillInput').focus(); // Focus v√†o input
  }
  
  function checkFillInTheBlank() {
      const w = currentWords[currentIndex];
      const input = document.getElementById('fillInput').value.trim().toLowerCase();
      // X·ª≠ l√Ω c√°c d·∫°ng t·ª´ (v√≠ d·ª•: s·ªë √≠t, s·ªë nhi·ªÅu) n·∫øu c√≥ th·ªÉ, t·∫°m th·ªùi ch·ªâ l·∫•y t·ª´ g·ªëc
      const correct = (w.english || '').toLowerCase().split(',').map(s => s.trim()); 
      const resultDiv = document.getElementById('fillResult');
      const answerDiv = document.getElementById('fillAnswer');

      if (correct.includes(input)) {
          resultDiv.style.color = 'var(--success)';
          resultDiv.innerText = 'Ch√≠nh x√°c! üéâ';
          updateHistory(w, true); // C·∫≠p nh·∫≠t ngay khi tr·∫£ l·ªùi ƒë√∫ng
          // T·ª± ƒë·ªông chuy·ªÉn
          setTimeout(() => nextCard(true), 1500);
      } else {
          resultDiv.style.color = 'var(--error)';
          resultDiv.innerText = 'Sai r·ªìi. üòî';
          answerDiv.style.color = 'var(--accent)';
          answerDiv.innerText = `ƒê√°p √°n ƒë√∫ng: ${w.english} (${w.vietnamese})`;
          updateHistory(w, false);
      }
  }

  function flipCard() {
    if (currentMode === 'flashcard') {
      isFlipped = !isFlipped;
      document.getElementById('flashcard').classList.toggle('is-flipped');
    }
  }

  function nextCard(isCorrect = true) {
    if (currentMode === 'fill' && !isCorrect) {
        // N·∫øu l√† fill in the blank v√† ch∆∞a tr·∫£ l·ªùi ƒë√∫ng, kh√¥ng cho next
        return; 
    }
    
    if (currentMode === 'flashcard') {
        // C·∫≠p nh·∫≠t l·ªãch s·ª≠ ch·ªâ khi ·ªü flashcard v√† b·∫•m next (gi·∫£ ƒë·ªãnh ƒë√£ xem)
        updateHistory(currentWords[currentIndex], isCorrect);
    }
    
    if (currentMode === 'flashcard' || currentMode === 'fill') {
      

      if (currentIndex < currentWords.length - 1) {
        currentIndex++;
      } else {
        alert("B·∫°n ƒë√£ ho√†n th√†nh l∆∞·ª£t h·ªçc n√†y! ƒêang chuy·ªÉn sang ch·ªß ƒë·ªÅ ti·∫øp theo.");
        autoSelectTopic();
        // Ki·ªÉm tra l·∫°i sau khi chuy·ªÉn ch·ªß ƒë·ªÅ
        if (Object.keys(allTopics).length > 0 && getUniqueWords(allTopics[currentTopicKey].words).length === 0) {
            alert("Tuy·ªát v·ªùi, b·∫°n ƒë√£ h·ªçc h·∫øt t·∫•t c·∫£ t·ª´ v·ª±ng!");
            closeGame();
            return;
        }
        startGame(currentMode);
        return;
      }
      
      if (currentMode === 'flashcard') renderFlashcard();
      if (currentMode === 'fill') renderFillInTheBlank();
    }
  }

  function prevCard() {
    if (currentMode === 'flashcard' || currentMode === 'fill') {
      if (currentIndex > 0) {
        currentIndex--;
      }
      if (currentMode === 'flashcard') renderFlashcard();
      if (currentMode === 'fill') renderFillInTheBlank();
    }
  }
  
  // --- MATCHING GAME LOGIC ---
  let matchingGame = { items: [], selected: null, matches: 0, totalPairs: 0 };

  function setupMatching() {
      const content = document.getElementById('gameContent');
      content.innerHTML = `
          <div style="font-size:1.1rem; margin-bottom:15px;">Gh√©p Ti·∫øng Anh v√† Ti·∫øng Vi·ªát</div>
          <div class="matching-grid" id="matchingGrid"></div>
          <div id="matchingStatus" style="margin-top: 20px; font-weight: bold;"></div>
          <button class="neu-btn" style="margin-top: 20px; color:white; background-color: var(--accent);" onclick="setupMatching()">
              <i class="fas fa-sync-alt"></i> Ch∆°i L·∫°i/T·ª´ kh√°c
          </button>
      `;
      
      const numPairs = Math.min(4, currentWords.length); // T·ªëi ƒëa 4 c·∫∑p
      matchingGame.totalPairs = numPairs;
      matchingGame.matches = 0;
      matchingGame.selected = null;
      
      // Ch·ªçn ng·∫´u nhi√™n c√°c t·ª´
      const shuffledWords = [...currentWords].sort(() => 0.5 - Math.random());
      const selectedWords = shuffledWords.slice(0, numPairs);
      
      matchingGame.items = [];
      selectedWords.forEach(w => {
          const key = getWordKey(w);
          matchingGame.items.push({ text: w.english, type: 'en', key: key, word: w });
          matchingGame.items.push({ text: w.vietnamese, type: 'vn', key: key, word: w });
      });
      
      // Tr·ªôn l·∫´n
      matchingGame.items.sort(() => 0.5 - Math.random());
      renderMatchingGrid();
  }
  
  function renderMatchingGrid() {
      const grid = document.getElementById('matchingGrid');
      grid.innerHTML = matchingGame.items.map((item, index) => `
          <div class="match-btn neu-box" data-index="${index}" data-type="${item.type}" onclick="selectMatchItem(${index})">
              ${item.text}
          </div>
      `).join('');
      
      document.getElementById('matchingStatus').innerText = `ƒê√£ gh√©p: ${matchingGame.matches}/${matchingGame.totalPairs}`;
  }
  
  function selectMatchItem(index) {
      const item = matchingGame.items[index];
      const btn = document.querySelector(`.match-btn[data-index="${index}"]`);
      
      if (btn.classList.contains('matched') || btn.classList.contains('mismatch')) return;

      if (!matchingGame.selected) {
          // Ch·ªçn l·∫ßn 1
          matchingGame.selected = { index, item, btn };
          btn.classList.add('selected');
      } else if (matchingGame.selected.index === index) {
          // H·ªßy ch·ªçn
          matchingGame.selected.btn.classList.remove('selected');
          matchingGame.selected = null;
      } else {
          // Ch·ªçn l·∫ßn 2
          const first = matchingGame.selected;
          const second = { index, item, btn };
          
          first.btn.classList.remove('selected');
          
          if (first.item.key === second.item.key && first.item.type !== second.item.type) {
              // Kh·ªõp ƒë√∫ng
              first.btn.classList.add('matched');
              second.btn.classList.add('matched');
              matchingGame.matches++;
              updateHistory(item.word, true); // C·∫≠p nh·∫≠t l·ªãch s·ª≠
              
              if (matchingGame.matches === matchingGame.totalPairs) {
                  document.getElementById('matchingStatus').innerText = `Ho√†n th√†nh! üéâ`;
                  // T·ª± ƒë·ªông load game m·ªõi sau 2s
                  setTimeout(() => setupMatching(), 2000); 
              }
              
          } else {
              // Kh·ªõp sai
              first.btn.classList.add('mismatch');
              second.btn.classList.add('mismatch');
              updateHistory(item.word, false);
              
              setTimeout(() => {
                  first.btn.classList.remove('mismatch');
                  second.btn.classList.remove('mismatch');
              }, 1000);
          }
          matchingGame.selected = null;
      }
  }

  // --- SMART QUIZ LOGIC ---
  let quizGame = { words: [], currentWord: null, questionIndex: 0, totalQuestions: 0 };
  const RETENTION_MONTHS = 4; // √în t·∫≠p trong 4 th√°ng

  function setupSmartQuiz(allWords) {
      const content = document.getElementById('gameContent');
      content.innerHTML = `
          <div class="quiz-question" id="quizQuestion"></div>
          <div class="quiz-options-grid" id="quizOptions"></div>
          <div id="quizResult" style="margin-top: 20px; font-weight: bold;"></div>
          <button class="neu-btn" style="margin-top: 20px; color:white; background-color: var(--accent);" onclick="nextQuizQuestion()">
              <i class="fas fa-arrow-right"></i> Ti·∫øp theo
          </button>
      `;
      
      // 1. L·ªçc t·ª´ c·∫ßn √¥n t·∫≠p (Ch∆∞a Mastered V√Ä h·ªçc trong 4 th√°ng g·∫ßn nh·∫•t)
      const fourMonthsAgo = Date.now() - (RETENTION_MONTHS * 30 * 24 * 60 * 60 * 1000);
      
      quizGame.words = allWords.filter(word => {
          const key = getWordKey(word);
          // Lo·∫°i t·ª´ ƒë√£ thu·ªôc
          if (masteredWords[key]) return false; 
          
          // Gi·ªØ l·∫°i t·ª´ ƒë√£ h·ªçc g·∫ßn ƒë√¢y
          const lastTime = historyWords[key] || 0;
          return lastTime >= fourMonthsAgo;
      });
      
      // N·∫øu kh√¥ng c√≥ t·ª´ √¥n t·∫≠p, l·∫•y ng·∫´u nhi√™n 10 t·ª´ ch∆∞a thu·ªôc
      if (quizGame.words.length === 0) {
          const uniqueWords = getUniqueWords(allWords);
          quizGame.words = uniqueWords.slice(0, Math.min(10, uniqueWords.length));
      }
      
      // Tr·ªôn l·∫´n v√† gi·ªõi h·∫°n 10 c√¢u h·ªèi
      quizGame.words.sort(() => 0.5 - Math.random());
      quizGame.words = quizGame.words.slice(0, 10);
      
      if (quizGame.words.length === 0) {
          document.getElementById('quizQuestion').innerText = "Tuy·ªát v·ªùi! B·∫°n ƒë√£ thu·ªôc h·∫øt t·ª´ v·ª±ng c·∫ßn √¥n t·∫≠p.";
          document.getElementById('quizOptions').innerHTML = '';
          document.querySelector(".controls-area").style.display = 'none';
          document.getElementById('cardCounter').style.display = 'none';
          return;
      }
      
      quizGame.questionIndex = 0;
      quizGame.totalQuestions = quizGame.words.length;
      document.querySelector(".controls-area").style.display = 'none';
      document.getElementById('cardCounter').style.display = 'block';

      nextQuizQuestion(true);
  }

  function nextQuizQuestion(isInit = false) {
      if (!isInit) {
          // Check n·∫øu ƒë√£ tr·∫£ l·ªùi xong c√¢u tr∆∞·ªõc
          const resultDiv = document.getElementById('quizResult');
          if (!resultDiv.innerText.includes('Ch√≠nh x√°c') && !resultDiv.innerText.includes('Sai r·ªìi')) {
              alert("Vui l√≤ng tr·∫£ l·ªùi c√¢u h·ªèi tr∆∞·ªõc.");
              return;
          }
          quizGame.questionIndex++;
      }

      if (quizGame.questionIndex >= quizGame.totalQuestions) {
          document.getElementById('quizQuestion').innerText = "Ho√†n th√†nh b√†i Quiz! üéâ";
          document.getElementById('quizOptions').innerHTML = '';
          document.getElementById('quizResult').innerText = "B·∫°n ƒë√£ ho√†n th√†nh l∆∞·ª£t √¥n t·∫≠p n√†y.";
          document.getElementById('cardCounter').innerText = `${quizGame.totalQuestions}/${quizGame.totalQuestions}`;
          setTimeout(() => closeGame(), 3000);
          return;
      }
      
      quizGame.currentWord = quizGame.words[quizGame.questionIndex];
      renderQuizQuestion();
  }

  function renderQuizQuestion() {
      const w = quizGame.currentWord;
      const allWords = allTopics[currentTopicKey].words;
      
      // L·∫•y 3 t·ª´ nhi·ªÖu (distractors)
      let distractors = allWords.filter(item => getWordKey(item) !== getWordKey(w))
                                .sort(() => 0.5 - Math.random())
                                .slice(0, 3);
      
      // T·∫°o c√°c l·ª±a ch·ªçn (s·ª≠ d·ª•ng nghƒ©a Ti·∫øng Vi·ªát)
      let options = [
          { text: w.vietnamese, isCorrect: true, word: w }
      ];
      distractors.forEach(d => {
          options.push({ text: d.vietnamese, isCorrect: false, word: d });
      });
      
      options.sort(() => 0.5 - Math.random()); // Tr·ªôn c√°c l·ª±a ch·ªçn

      document.getElementById('quizQuestion').innerText = `D·ªãch t·ª´ ti·∫øng Anh: "${w.english}"`;
      document.getElementById('quizResult').innerText = '';
      
      document.getElementById('quizOptions').innerHTML = options.map((opt, index) => `
          <button class="neu-btn quiz-option-btn" data-correct="${opt.isCorrect}" data-key="${getWordKey(opt.word)}" onclick="checkQuizAnswer(this, ${opt.isCorrect})">
              ${opt.text}
          </button>
      `).join('');
      
      document.getElementById('cardCounter').innerText = `${quizGame.questionIndex + 1}/${quizGame.totalQuestions}`;
  }

  function checkQuizAnswer(button, isCorrect) {
      const resultDiv = document.getElementById('quizResult');
      const allButtons = document.querySelectorAll('.quiz-option-btn');
      
      // V√¥ hi·ªáu h√≥a t·∫•t c·∫£ c√°c n√∫t sau khi ch·ªçn
      allButtons.forEach(btn => btn.disabled = true);
      
      if (isCorrect) {
          button.classList.add('correct');
          resultDiv.style.color = 'var(--success)';
          resultDiv.innerText = 'Ch√≠nh x√°c! üéâ';
          updateHistory(quizGame.currentWord, true);
      } else {
          button.classList.add('incorrect');
          // Highlight ƒë√°p √°n ƒë√∫ng
          document.querySelector('.quiz-option-btn[data-correct="true"]').classList.add('correct');
          resultDiv.style.color = 'var(--error)';
          resultDiv.innerText = `Sai r·ªìi. üòî ƒê√°p √°n ƒë√∫ng l√†: "${quizGame.currentWord.vietnamese}"`;
          updateHistory(quizGame.currentWord, false);
      }
  }

  // --- HISTORY & MASTERED LOGIC ---
  function updateHistory(word, isCorrect) {
      const key = getWordKey(word);
      // C·∫≠p nh·∫≠t l·ªãch s·ª≠ (th·ªùi gian h·ªçc g·∫ßn nh·∫•t)
      historyWords[key] = Date.now();
      localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(historyWords));
      
      // N·∫øu tr·∫£ l·ªùi sai, ƒë·∫£m b·∫£o t·ª´ n√†y kh√¥ng b·ªã Mastered
      if (!isCorrect) {
          if (masteredWords[key]) {
             delete masteredWords[key];
             localStorage.setItem(STORAGE_KEY_MASTERED, JSON.stringify(masteredWords));
             renderTopicList(); // C·∫≠p nh·∫≠t s·ªë t·ª´
          }
      }
  }
  
  function toggleMastered(word) {
      const key = getWordKey(word);
      if (masteredWords[key]) {
          delete masteredWords[key];
          alert(`ƒê√£ g·ª° "${word.english}" kh·ªèi danh s√°ch ƒë√£ thu·ªôc.`);
      } else {
          masteredWords[key] = true;
          alert(`ƒê√£ ƒë√°nh d·∫•u "${word.english}" l√† ƒë√£ thu·ªôc!`);
          // T·ª± ƒë·ªông chuy·ªÉn sang t·ª´ ti·∫øp theo n·∫øu ƒëang ·ªü flashcard/fill
          if (currentMode === 'flashcard' || currentMode === 'fill') {
              // C·∫≠p nh·∫≠t l·ªãch s·ª≠ l√† ƒë√∫ng tr∆∞·ªõc khi next
              updateHistory(word, true); 
              nextCard(true); 
          }
      }
      localStorage.setItem(STORAGE_KEY_MASTERED, JSON.stringify(masteredWords));
      renderTopicList(); // C·∫≠p nh·∫≠t s·ªë t·ª´
  }
  
  // --- TEXT TO SPEECH ---
  function speakCurrentWord() {
    let wordToSpeak = '';
    
    // L·∫•y t·ª´ c·∫ßn n√≥i t√πy theo mode
    if (currentMode === 'flashcard' || currentMode === 'fill') {
        if(currentWords[currentIndex]) {
            wordToSpeak = currentWords[currentIndex].english;
        }
    } else if (currentMode === 'quiz' && quizGame.currentWord) {
        wordToSpeak = quizGame.currentWord.english;
    }

    if (!wordToSpeak) return;

    // Fix bug: Kh√¥ng ch·∫°y TTS tr√™n m·ªôt s·ªë tr√¨nh duy·ªát n·∫øu kh√¥ng c√≥ h√†m n√†y
    if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(wordToSpeak);
        
        const rate = parseFloat(document.getElementById('speedRate').value || 1.0);
        utterance.rate = rate;
        utterance.lang = 'en-US';
        
        // Th√™m event l·∫Øng nghe ƒë·ªÉ tr√°nh bug kh√¥ng ƒë·ªçc l·∫ßn ƒë·∫ßu
        utterance.onend = () => {};
        utterance.onerror = (e) => console.error('TTS Error:', e);

        window.speechSynthesis.speak(utterance);
    } else {
        alert("Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Text-to-Speech.");
    }
  }

  // --- KEYBOARD CONTROLS ---
  document.addEventListener('keydown', (e) => {
    if(document.getElementById('gameOverlay').style.display === 'flex') {
      // C√°c ph√≠m ƒëi·ªÅu h∆∞·ªõng ch·ªâ d√πng cho Flashcard v√† Fill
      if (currentMode === 'flashcard' || currentMode === 'fill') {
          if(e.key === 'ArrowRight') nextCard();
          if(e.key === 'ArrowLeft') prevCard();
      }
      
      if(e.key === ' ' || e.key === 'Enter') {
          e.preventDefault(); // NgƒÉn cu·ªôn trang
          if (currentMode === 'flashcard') flipCard();
          // ƒê·ªëi v·ªõi Fill, Enter ƒë∆∞·ª£c x·ª≠ l√Ω trong input
      }
      if(e.key === 'v' || e.key === 'V') {
          e.preventDefault();
          speakCurrentWord();
      }
    }
  });

</script>
</body>
</html>
